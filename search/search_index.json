{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This documentation details the SmartGlass protocol, used by the Xbox One gaming console family. Introduction SmartGlass is a remote control protocol developed by Microsoft for their Xbox gaming system. It was originally developed for the Xbox 360, where it relied on an active Xbox Live connection for communication with the console. With the Xbox One it directly communicates over the local network. In this documentation only the Xbox One variant of SmartGlass is documented. Browse the wiki Basics Cryptography Simple Message Message Channels Nano Protocol Capabilities Here is a rough overview about the capabilities of the SmartGlass protocol. ~~Start games / apps via TitleID~~ (this feature got removed from the protocol by Microsoft, with ~Sysupdate 10.0.11763.4088 // 04/2019) Controller input ( Input Channel ) Media player control ( Media Channel ) Text input ( Text Channel ) Live TV streaming ( Stump Channel ) Gamestreaming ( Broadcast Channel / NANO ) and more... Related specifications The following specifications share similarities with the Xbox specific protocols. SmartGlass protocol MS-CDP: Connected Devices Platform Nano protocol (v1/v2) MS-RDPEUDP: RDP:UDP TransportExtension XCloud (Nano v3) MS-SRTP: Secure Real-time Transport Protocol (SRTP) Profile Disclaimer Xbox, Xbox One, Smartglass and Xbox Live are trademarks of Microsoft Corporation. Team OpenXbox is in no way endorsed by or affiliated with Microsoft Corporation, or any associated subsidiaries, logos or trademarks.","title":"Home"},{"location":"#welcome","text":"This documentation details the SmartGlass protocol, used by the Xbox One gaming console family.","title":"Welcome"},{"location":"#introduction","text":"SmartGlass is a remote control protocol developed by Microsoft for their Xbox gaming system. It was originally developed for the Xbox 360, where it relied on an active Xbox Live connection for communication with the console. With the Xbox One it directly communicates over the local network. In this documentation only the Xbox One variant of SmartGlass is documented.","title":"Introduction"},{"location":"#browse-the-wiki","text":"Basics Cryptography Simple Message Message Channels Nano Protocol","title":"Browse the wiki"},{"location":"#capabilities","text":"Here is a rough overview about the capabilities of the SmartGlass protocol. ~~Start games / apps via TitleID~~ (this feature got removed from the protocol by Microsoft, with ~Sysupdate 10.0.11763.4088 // 04/2019) Controller input ( Input Channel ) Media player control ( Media Channel ) Text input ( Text Channel ) Live TV streaming ( Stump Channel ) Gamestreaming ( Broadcast Channel / NANO ) and more...","title":"Capabilities"},{"location":"#related-specifications","text":"The following specifications share similarities with the Xbox specific protocols.","title":"Related specifications"},{"location":"#smartglass-protocol","text":"MS-CDP: Connected Devices Platform","title":"SmartGlass protocol"},{"location":"#nano-protocol-v1v2","text":"MS-RDPEUDP: RDP:UDP TransportExtension","title":"Nano protocol (v1/v2)"},{"location":"#xcloud-nano-v3","text":"MS-SRTP: Secure Real-time Transport Protocol (SRTP) Profile","title":"XCloud (Nano v3)"},{"location":"#disclaimer","text":"Xbox, Xbox One, Smartglass and Xbox Live are trademarks of Microsoft Corporation. Team OpenXbox is in no way endorsed by or affiliated with Microsoft Corporation, or any associated subsidiaries, logos or trademarks.","title":"Disclaimer"},{"location":"basics/","text":"SmartGlass Protocol SmartGlass Protocol Basic communication Client connection Packet layout Strings in SmartGlass packets Basic communication The SmartGlass protocol communicates over UDP port 5050. Only the discovery and power on messages are transmitted in plain text, the rest is encrypted (see Cryptography ). Nano protocol uses dynamic ports (UDP/TCP), negotioated via SmartGlass protocol's broadcast channel. Client connection Console might be powered on by Power On packet Client sends Discovery Request to console Console responds with Discovery Response Client parses Certificate in that response Client sets up a Crypto Context using the console's public key Client sends a Connect Request to the console Console responds with Connect Response Client sends a Local Join Message , announcing itself Upon Acknowledgement client opens several Channels Received / sent Heartbeat packets ensure that client/host is alive Packet layout General packet layout looks like the following: Name Note Packet Header Either SimpleMessage or Message Unprotected Payload For all SimpleMessage packets Protected Payload For Connect or Message packet *Hash Only if packet has Protected Payload , see Message Authentication NOTE: All numeric values in the SmartGlass Protocol are in network / big-endian byteorder. Strings in SmartGlass packets Usually strings are represented like the following: Type Description uint16 String length (excl. null-terminator) uchar * length String uchar '\\0' Null-terminator In this documentation, these strings are referenced as SGString","title":"Basics"},{"location":"basics/#smartglass-protocol","text":"SmartGlass Protocol Basic communication Client connection Packet layout Strings in SmartGlass packets","title":"SmartGlass Protocol"},{"location":"basics/#basic-communication","text":"The SmartGlass protocol communicates over UDP port 5050. Only the discovery and power on messages are transmitted in plain text, the rest is encrypted (see Cryptography ). Nano protocol uses dynamic ports (UDP/TCP), negotioated via SmartGlass protocol's broadcast channel.","title":"Basic communication"},{"location":"basics/#client-connection","text":"Console might be powered on by Power On packet Client sends Discovery Request to console Console responds with Discovery Response Client parses Certificate in that response Client sets up a Crypto Context using the console's public key Client sends a Connect Request to the console Console responds with Connect Response Client sends a Local Join Message , announcing itself Upon Acknowledgement client opens several Channels Received / sent Heartbeat packets ensure that client/host is alive","title":"Client connection"},{"location":"basics/#packet-layout","text":"General packet layout looks like the following: Name Note Packet Header Either SimpleMessage or Message Unprotected Payload For all SimpleMessage packets Protected Payload For Connect or Message packet *Hash Only if packet has Protected Payload , see Message Authentication NOTE: All numeric values in the SmartGlass Protocol are in network / big-endian byteorder.","title":"Packet layout"},{"location":"basics/#strings-in-smartglass-packets","text":"Usually strings are represented like the following: Type Description uint16 String length (excl. null-terminator) uchar * length String uchar '\\0' Null-terminator In this documentation, these strings are referenced as SGString","title":"Strings in SmartGlass packets"},{"location":"channels/","text":"Channels There are messages and status reports which service a specific area, they communicate on their own Channel (indicated by the Service Channel field in the message header). All channel communication is of type Message . Channels Core Channel Acknowledging Messages Service Channels Acquiring a channel Input Channel Input TV Remote Channel Stump Message Type Message Id Generation Assemble HTTP Streaming URL HDMI GUID Stump Source Stump Quality Stump Notification Stump Filter Type Stump Base Message Request Response Get Configuration Get Headend Info Get Live TV Info Get Program Info Get Tuner Lineups Get AppChannel Lineups Get AppChannel Program Data Get AppChannel Data Ensure Streaming started Set Channel Params Get recent Channels Send Key Media Channel Text Channel Broadcast Channel How to start gamestreaming? Broadcast Message Type Messages Gamestream Start Message Gamestream Stop Message Gamestream State Message Gamestream State Initializing Started Stopped Paused Gamestream Enabled Message Gamestream Error Message Gamestream Error Gamestream Telemetry Message Gamestream Preview Status Message Title Channel Title handshaking Packet structure Core Channel Core Channel is 0 . Acknowledging Messages Console sends packets of type Acknowledgement on channel 0x1000000000000000 , Client sends Acks on Core Channel . Service Channels Click on the channel in the following table to get more information. Channel GUID SystemInput fa20b8ca-66fb-46e0-adb60b978a59d35f SystemInputTVRemote d451e3b3-60bb-4c71-b3dbf994b1aca3a7 SystemMedia 48a9ca24-eb6d-4e12-8c43d57469edd3cd SystemText 7af3e6a2-488b-40cb-a93179c04b7da3a0 SystemBroadcast b6a117d8-f5e2-45d7-862e8fd8e3156476 Title 00000000-0000-0000-0000000000000000 Acquiring a channel After Local Join is done successfully, client can start additional Service Channel . Example The following messaging happens on Core Channel . Start with Request Id 0 Client sends Channel Start Request with current Request Id and Target Service Channel GUID to console Console replies with Channel Start Response Make sure Request Id in response matches the request Check result code of response, has to be 0 for success Use Target Channel Id , delivered in the response, to communicate with that channel ... Send next Channel Start Request with incremented Request Id ... Input Channel Control console via gamepad controls, touch, accelerometer, gyroscope etc. Used messages: Gamepad Title Touch System Touch Accelerometer Gyrometer Inclinometer Compass Orientation Input TV Remote Channel Also known as Stump , controls configured infrared devices via Xbox's IR Blaster and makes it possible to stream LiveTV and maybe HDMI IN. Communication is completely JSON -based. Stump Message Type Name String Value Error Error Ensure Streaming Started EnsureStreamingStarted Get Configuration GetConfiguration Get Headend Info GetHeadendInfo Get LiveTV Info GetLiveTVInfo Get Program Info GetProgrammInfo Get Recent Channels GetRecentChannels Get Tuner Lineups GetTunerLineups Get AppChannel Data GetAppChannelData Get AppChannel Lineups GetAppChannelLineups Get AppChannel Program Data GetAppChannelProgramData Send Key SendKey Set Channel SetChannel Message Id Generation An example of a messageid (Android client): 7edcf9d0.14 . Generate a random int, called Message Id Prefix , from 0 to 0x7FFFFFFF . Initialize a Message Id Index with 1 Concat both values, splitted by . : Prefix: 7edcf9d0 , Index: 1 => 7edcf9d0.1 For each new request that's sent to the console, Message Id Index gets incremented: 7edcf9d0.2 , 7edcf9d0.3 NOTE: AppChannel stuff uses a GUID as Message Id Assemble HTTP Streaming URL TODO HDMI GUID BA5EBA11-DEA1-4BAD-BA11-FEDDEADFAB1E Stump Source Name String Value HDMI hdmi USB TV Tuner tuner Stump Quality Name String Value Low Quality low Medium Quality medium High Quality high Best Quality best Stump Notification Name String Value Streaming Error StreamingError Channel Changed ChannelChanged Channel Type Changed ChannelTypeChanged Configuration Changed ConfigurationChanged Device UI Changed DeviceUIChanged Headend Changed HeadendChanged Video Format Changed VideoFormatChanged Program Changed ProgrammChanged Tunerstate Changed TunerStateChanged Stump Filter Type Name String Value All ALL HD and SD HDSD Only HD HD Stump Base Message Request Direction: Client -> Console { \"request\": \"Stump Message Type goes here\", \"msgid\": \"Generated Message Id goes here\", \"params\": \"Either null/None or some other parameters\" } Response Direction: Console -> Client Regular response { \"response\": \"Same as request value\", \"msgid\": \"Same as request value\", \"params\": \"Requested data\" } Notification { \"notification\": \"notification value\", // Maybe some other value? } Error { \"response\": \"Error\", \"msgid\": \"Same as request value\", \"error\": \"Some error text\" } Get Configuration Value: GetConfiguration Request Parameters None Response Parameters [ { \"device_id\": \"0\", \"device_type\": \"tv\", \"buttons\": { \"btn.back\": \"Back\", \"btn.up\": \"Up\", \"btn.red\": \"Red\", // and more... } }, { \"device_id\": \"1\", \"device_type\": \"stb\", \"buttons\": {} }, { // ... \"device_type\": \"tuner\" } ] Get Headend Info Value: GetHeadendInfo Request Parameters None Response Parameters { \"headendId\": \"dbd2530a-fcd5-8ff0-b89d-20cd7e021502\", \"providerName\": \"Sky Deutschland\", \"headendLocale\": \"de-DE\", \"providers\": [ { \"headendId\": \"DBD2530A-FCD5-8FF0-B89D-20CD7E021502\", \"providerName\": \"Sky Deutschland\", \"source\": \"hdmi\", \"titleId\": \"162615AD\", \"filterPreference\": \"HDSD\", \"canStream\": \"false\" }, { \"headendId\": \"D130DB0D-6CBC-328C-A30F-A514C0D0F377\", \"providerName\": \"Unity Media\", \"source\": \"tuner\", \"titleId\": \"162615AD\", \"filterPreference\": \"ALL\", \"canStream\": \"true\" } ], \"blockExplicitContentPerShow\": false, \"dvrEnabled\": false } Get Live TV Info Value: GetLiveTVInfo Request Parameters None Response Parameters { \"inHdmiMode\": \"1\" } Get Program Info Value: GetProgrammInfo Request Parameters None Response Parameters // Unknown Get Tuner Lineups Value: GetTunerLineups Request Parameters None Response Parameters { \"providers\":[ { \"headendId\":\"D130DB0D-6CBC-328C-A30F-A514C0D0F377\", \"cqsChannels\":[ ], \"foundChannels\":[ ] } ] } Get AppChannel Lineups Value: GetAppChannelLineups Request Parameters None Response Parameters [ { \"id\":\"LiveTvHdmiProvider\", \"providerName\":\"OneGuide\", \"primaryColor\":\"ff107c10\", \"secondaryColor\":\"ffebebeb\", \"titleId\":\"0BB0AAE5\", \"channels\":[ ] }, { \"id\":\"LiveTvPlaylistProvider\", \"providerName\":\"OneGuide\", \"primaryColor\":\"ff107c10\", \"secondaryColor\":\"ffebebeb\", \"titleId\":\"0BB0AAE5\", \"channels\":[ { \"id\":\"PromoAppChannel\", \"name\":\"More app channels\" } ] }, { \"id\":\"LiveTvUsbProvider\", \"providerName\":\"OneGuide\", \"primaryColor\":\"ff107c10\", \"secondaryColor\":\"ffebebeb\", \"titleId\":\"0BB0AAE5\", \"channels\":[ ] } ] Get AppChannel Program Data Value: GetAppChannelProgramData Request Parameters { \"providerId\": \"provider id goes here\", \"programId\": \"program id goes here\" } Response Parameters // Unknown Get AppChannel Data Value: GetAppChannelData Request Parameters { \"providerId\": \"provider id goes here\", \"channelId\": \"channel id goes here\", \"id\": \"channel id again\" } Response Parameters // Unknown Ensure Streaming started Value: EnsureStreamingStarted Request Parameters { \"source\": \"stump source goes here\"} Response Parameters // Unknown Set Channel Params Value: SetChannel Request Parameters By Id: { \"channelId\": \"target Channel Id\", \"lineupInstanceId\": \"target Lineup Id\" } By Name: { \"channel_name\": \"target channel name\" } Response Parameters // Unknown Get recent Channels Value: GetRecentChannels Request Paramters { \"startindex\": 0, \"count\": 50 } Response Parameters [ \"list\", \"of\", \"channels\"] Send Key Value: SendKey Request Parameters { \"button_id\": \"button id string\", // optional: // \"device_id\": \"target device id\" } Response Parameters True on success, False on error Media Channel Get info about currently playing media and control the playback. Used messages: Media Controller Removed Media Command Media Command Result Media State Text Channel Input Text whenever a text-dialog is shown on Xbox. Used messages: Title Text Configuration Title Text Input Title Text Selection System Text Configuration System Text Input System Text Acknowledge System Text Done Broadcast Channel Initializing of Gamestreaming is done over this channel. Communication is completely JSON -based. Actual streaming is done over Nano . Messages actively sent from client to console: Gamestream Start Message Gamestream Stop Message The other messages are basically status messages sent from console to client. How to start gamestreaming? Open the SystemBroadcast channel. Console sends a Gamestream Enabled Message . Check the field enabled if it's possible to use Gamestreaming (e.g. if it's activated). Send a Gamestream Start Message to the console. Console sends some Gamestream State Messages . Get the connection data from State: Initializing . Use Nano to connect to the console. Broadcast Message Type Type Value Sent by Start Gamestream 0x01 Client Stop Gamestream 0x02 Client Gamestream State 0x03 Console Gamestream Enabled 0x04 Console Gamestream Error 0x05 Console Telemetry 0x06 Console Preview Status 0x07 Console Messages Gamestream Start Message Type: 0x1 Direction: Client -> Console NOTE: Some values could be int or bool rather than string but the following example is the original format that gets sent from the original Windows 10 client { \"type\": 1, \"configuration\": { \"urcpType\": \"0\", \"urcpFixedRate\": \"-1\", \"urcpMaximumWindow\": \"1310720\", \"urcpMinimumRate\": \"256000\", \"urcpMaximumRate\": \"10000000\", \"urcpKeepAliveTimeoutMs\": \"0\", \"audioFecType\": \"0\", \"videoFecType\": \"0\", \"videoFecLevel\": \"3\", \"videoPacketUtilization\": \"0\", \"enableDynamicBitrate\": \"false\", \"dynamicBitrateScaleFactor\": \"1\", \"dynamicBitrateUpdateMs\": \"5000\", \"sendKeyframesOverTCP\": \"false\", \"videoMaximumWidth\": \"1280\", \"videoMaximumHeight\": \"720\", \"videoMaximumFrameRate\": \"60\", \"videoPacketDefragTimeoutMs\": \"16\", \"enableVideoFrameAcks\": \"false\", \"enableAudioChat\": \"true\", \"audioBufferLengthHns\": \"10000000\", \"audioSyncPolicy\": \"1\", \"audioSyncMinLatency\": \"10\", \"audioSyncDesiredLatency\": \"40\", \"audioSyncMaxLatency\": \"170\", \"audioSyncCompressLatency\": \"100\", \"audioSyncCompressFactor\": \"0.99\", \"audioSyncLengthenFactor\": \"1.01\", \"enableOpusAudio\": \"false\", \"enableOpusChatAudio\": \"true\", \"inputReadsPerSecond\": \"120\", \"udpMaxSendPacketsInWinsock\": \"250\", \"udpSubBurstGroups\": \"0\", \"udpBurstDurationMs\": \"12\" }, \"reQueryPreviewStatus\": false } Gamestream Stop Message Type: 0x2 Direction: Client -> Console / never seen in the wild { \"type\": 2 } Gamestream State Message Type: 0x3 Direction: Console -> Client All gamestream state messages use a state field, declared in the following table. Gamestream State State Value Initializing 0x01 Started 0x02 Stopped 0x03 Paused 0x04 Initializing { \"type\": 3, \"state\": 1, \"sessionId\": \"{123E4567-E89b-12D3-A456-426655440000}\", \"udpPort\": 55068, \"tcpPort\": 52556 } Started { \"type\": 3, \"state\": 2, \"sessionId\": \"{123E4567-E89b-12D3-A456-426655440000}\", \"isWirelessConnection\": false, \"wirelessChannel\": 0, \"transmitLinkSpeed\": 1000000000 } Stopped { \"type\": 3, \"state\": 3, \"sessionId\": \"{123E4567-E89b-12D3-A456-426655440000}\" } Paused // Never seen in the wild Gamestream Enabled Message Type: 0x4 Direction: Console -> Client { \"type\": 4, \"enabled\": true, \"canBeEnabled\": true, \"majorProtocolVersion\": 6, \"minorProtocolVersion\": 0 } Gamestream Error Message Type: 0x5 Direction: Console -> Client { \"type\": 5, \"errorType\": 1, \"errorValue\": 1234 } Gamestream Error Error Value General 0x01 Failed to instantiate 0x02 Failed to initialize 0x03 Failed to start 0x04 Failed to stop 0x05 No Controller 0x06 Different MSA active 0x07 DRM Video 0x08 HDCP Video 0x09 Kinect Title 0x0A Prohibited Game 0x0B Poor network connection 0x0C Streaming disabled 0x0D Cannot reach console 0x0E Generic Error 0x0F Version mismatch 0x10 No profile 0x11 Broadcast in progress 0x12 Gamestream Telemetry Message Type: 0x6 Direction: Unknown / never seen in the wild { \"type\": 6 } Gamestream Preview Status Message Type: 0x7 Direction: Console -> Client { \"type\": 7, \"isPublicPreview\": false, \"isInternalPreview\": false } Title Channel The title channel is used if the running title (aka. game) supports the SmartGlass Experience (for example: Fallout 4). For opening the Service Channel you have to send a Title Id while acquiring the channel . Title channel does basic communication over the Core channel : Auxiliary Stream Active Surface Change NOTE: For title specific data additional sockets are used! Title handshaking Flow to get connection data for title communication: Client sends Auxiliary Stream Handshake Host responds with Auxiliary Stream Handshake Client sends Auxiliary Stream Handshake again Host responds with Auxiliary Stream Connection Info Client sets up Auxiliary crypto context Client connects to advertised Title endpoints Packet structure TODO","title":"Channels"},{"location":"channels/#channels","text":"There are messages and status reports which service a specific area, they communicate on their own Channel (indicated by the Service Channel field in the message header). All channel communication is of type Message . Channels Core Channel Acknowledging Messages Service Channels Acquiring a channel Input Channel Input TV Remote Channel Stump Message Type Message Id Generation Assemble HTTP Streaming URL HDMI GUID Stump Source Stump Quality Stump Notification Stump Filter Type Stump Base Message Request Response Get Configuration Get Headend Info Get Live TV Info Get Program Info Get Tuner Lineups Get AppChannel Lineups Get AppChannel Program Data Get AppChannel Data Ensure Streaming started Set Channel Params Get recent Channels Send Key Media Channel Text Channel Broadcast Channel How to start gamestreaming? Broadcast Message Type Messages Gamestream Start Message Gamestream Stop Message Gamestream State Message Gamestream State Initializing Started Stopped Paused Gamestream Enabled Message Gamestream Error Message Gamestream Error Gamestream Telemetry Message Gamestream Preview Status Message Title Channel Title handshaking Packet structure","title":"Channels"},{"location":"channels/#core-channel","text":"Core Channel is 0 .","title":"Core Channel"},{"location":"channels/#acknowledging-messages","text":"Console sends packets of type Acknowledgement on channel 0x1000000000000000 , Client sends Acks on Core Channel .","title":"Acknowledging Messages"},{"location":"channels/#service-channels","text":"Click on the channel in the following table to get more information. Channel GUID SystemInput fa20b8ca-66fb-46e0-adb60b978a59d35f SystemInputTVRemote d451e3b3-60bb-4c71-b3dbf994b1aca3a7 SystemMedia 48a9ca24-eb6d-4e12-8c43d57469edd3cd SystemText 7af3e6a2-488b-40cb-a93179c04b7da3a0 SystemBroadcast b6a117d8-f5e2-45d7-862e8fd8e3156476 Title 00000000-0000-0000-0000000000000000","title":"Service Channels"},{"location":"channels/#acquiring-a-channel","text":"After Local Join is done successfully, client can start additional Service Channel . Example The following messaging happens on Core Channel . Start with Request Id 0 Client sends Channel Start Request with current Request Id and Target Service Channel GUID to console Console replies with Channel Start Response Make sure Request Id in response matches the request Check result code of response, has to be 0 for success Use Target Channel Id , delivered in the response, to communicate with that channel ... Send next Channel Start Request with incremented Request Id ...","title":"Acquiring a channel"},{"location":"channels/#input-channel","text":"Control console via gamepad controls, touch, accelerometer, gyroscope etc. Used messages: Gamepad Title Touch System Touch Accelerometer Gyrometer Inclinometer Compass Orientation","title":"Input Channel"},{"location":"channels/#input-tv-remote-channel","text":"Also known as Stump , controls configured infrared devices via Xbox's IR Blaster and makes it possible to stream LiveTV and maybe HDMI IN. Communication is completely JSON -based.","title":"Input TV Remote Channel"},{"location":"channels/#stump-message-type","text":"Name String Value Error Error Ensure Streaming Started EnsureStreamingStarted Get Configuration GetConfiguration Get Headend Info GetHeadendInfo Get LiveTV Info GetLiveTVInfo Get Program Info GetProgrammInfo Get Recent Channels GetRecentChannels Get Tuner Lineups GetTunerLineups Get AppChannel Data GetAppChannelData Get AppChannel Lineups GetAppChannelLineups Get AppChannel Program Data GetAppChannelProgramData Send Key SendKey Set Channel SetChannel","title":"Stump Message Type"},{"location":"channels/#message-id-generation","text":"An example of a messageid (Android client): 7edcf9d0.14 . Generate a random int, called Message Id Prefix , from 0 to 0x7FFFFFFF . Initialize a Message Id Index with 1 Concat both values, splitted by . : Prefix: 7edcf9d0 , Index: 1 => 7edcf9d0.1 For each new request that's sent to the console, Message Id Index gets incremented: 7edcf9d0.2 , 7edcf9d0.3 NOTE: AppChannel stuff uses a GUID as Message Id","title":"Message Id Generation"},{"location":"channels/#assemble-http-streaming-url","text":"TODO","title":"Assemble HTTP Streaming URL"},{"location":"channels/#hdmi-guid","text":"BA5EBA11-DEA1-4BAD-BA11-FEDDEADFAB1E","title":"HDMI GUID"},{"location":"channels/#stump-source","text":"Name String Value HDMI hdmi USB TV Tuner tuner","title":"Stump Source"},{"location":"channels/#stump-quality","text":"Name String Value Low Quality low Medium Quality medium High Quality high Best Quality best","title":"Stump Quality"},{"location":"channels/#stump-notification","text":"Name String Value Streaming Error StreamingError Channel Changed ChannelChanged Channel Type Changed ChannelTypeChanged Configuration Changed ConfigurationChanged Device UI Changed DeviceUIChanged Headend Changed HeadendChanged Video Format Changed VideoFormatChanged Program Changed ProgrammChanged Tunerstate Changed TunerStateChanged","title":"Stump Notification"},{"location":"channels/#stump-filter-type","text":"Name String Value All ALL HD and SD HDSD Only HD HD","title":"Stump Filter Type"},{"location":"channels/#stump-base-message","text":"","title":"Stump Base Message"},{"location":"channels/#request","text":"Direction: Client -> Console { \"request\": \"Stump Message Type goes here\", \"msgid\": \"Generated Message Id goes here\", \"params\": \"Either null/None or some other parameters\" }","title":"Request"},{"location":"channels/#response","text":"Direction: Console -> Client Regular response { \"response\": \"Same as request value\", \"msgid\": \"Same as request value\", \"params\": \"Requested data\" } Notification { \"notification\": \"notification value\", // Maybe some other value? } Error { \"response\": \"Error\", \"msgid\": \"Same as request value\", \"error\": \"Some error text\" }","title":"Response"},{"location":"channels/#get-configuration","text":"Value: GetConfiguration Request Parameters None Response Parameters [ { \"device_id\": \"0\", \"device_type\": \"tv\", \"buttons\": { \"btn.back\": \"Back\", \"btn.up\": \"Up\", \"btn.red\": \"Red\", // and more... } }, { \"device_id\": \"1\", \"device_type\": \"stb\", \"buttons\": {} }, { // ... \"device_type\": \"tuner\" } ]","title":"Get Configuration"},{"location":"channels/#get-headend-info","text":"Value: GetHeadendInfo Request Parameters None Response Parameters { \"headendId\": \"dbd2530a-fcd5-8ff0-b89d-20cd7e021502\", \"providerName\": \"Sky Deutschland\", \"headendLocale\": \"de-DE\", \"providers\": [ { \"headendId\": \"DBD2530A-FCD5-8FF0-B89D-20CD7E021502\", \"providerName\": \"Sky Deutschland\", \"source\": \"hdmi\", \"titleId\": \"162615AD\", \"filterPreference\": \"HDSD\", \"canStream\": \"false\" }, { \"headendId\": \"D130DB0D-6CBC-328C-A30F-A514C0D0F377\", \"providerName\": \"Unity Media\", \"source\": \"tuner\", \"titleId\": \"162615AD\", \"filterPreference\": \"ALL\", \"canStream\": \"true\" } ], \"blockExplicitContentPerShow\": false, \"dvrEnabled\": false }","title":"Get Headend Info"},{"location":"channels/#get-live-tv-info","text":"Value: GetLiveTVInfo Request Parameters None Response Parameters { \"inHdmiMode\": \"1\" }","title":"Get Live TV Info"},{"location":"channels/#get-program-info","text":"Value: GetProgrammInfo Request Parameters None Response Parameters // Unknown","title":"Get Program Info"},{"location":"channels/#get-tuner-lineups","text":"Value: GetTunerLineups Request Parameters None Response Parameters { \"providers\":[ { \"headendId\":\"D130DB0D-6CBC-328C-A30F-A514C0D0F377\", \"cqsChannels\":[ ], \"foundChannels\":[ ] } ] }","title":"Get Tuner Lineups"},{"location":"channels/#get-appchannel-lineups","text":"Value: GetAppChannelLineups Request Parameters None Response Parameters [ { \"id\":\"LiveTvHdmiProvider\", \"providerName\":\"OneGuide\", \"primaryColor\":\"ff107c10\", \"secondaryColor\":\"ffebebeb\", \"titleId\":\"0BB0AAE5\", \"channels\":[ ] }, { \"id\":\"LiveTvPlaylistProvider\", \"providerName\":\"OneGuide\", \"primaryColor\":\"ff107c10\", \"secondaryColor\":\"ffebebeb\", \"titleId\":\"0BB0AAE5\", \"channels\":[ { \"id\":\"PromoAppChannel\", \"name\":\"More app channels\" } ] }, { \"id\":\"LiveTvUsbProvider\", \"providerName\":\"OneGuide\", \"primaryColor\":\"ff107c10\", \"secondaryColor\":\"ffebebeb\", \"titleId\":\"0BB0AAE5\", \"channels\":[ ] } ]","title":"Get AppChannel Lineups"},{"location":"channels/#get-appchannel-program-data","text":"Value: GetAppChannelProgramData Request Parameters { \"providerId\": \"provider id goes here\", \"programId\": \"program id goes here\" } Response Parameters // Unknown","title":"Get AppChannel Program Data"},{"location":"channels/#get-appchannel-data","text":"Value: GetAppChannelData Request Parameters { \"providerId\": \"provider id goes here\", \"channelId\": \"channel id goes here\", \"id\": \"channel id again\" } Response Parameters // Unknown","title":"Get AppChannel Data"},{"location":"channels/#ensure-streaming-started","text":"Value: EnsureStreamingStarted Request Parameters { \"source\": \"stump source goes here\"} Response Parameters // Unknown","title":"Ensure Streaming started"},{"location":"channels/#set-channel-params","text":"Value: SetChannel Request Parameters By Id: { \"channelId\": \"target Channel Id\", \"lineupInstanceId\": \"target Lineup Id\" } By Name: { \"channel_name\": \"target channel name\" } Response Parameters // Unknown","title":"Set Channel Params"},{"location":"channels/#get-recent-channels","text":"Value: GetRecentChannels Request Paramters { \"startindex\": 0, \"count\": 50 } Response Parameters [ \"list\", \"of\", \"channels\"]","title":"Get recent Channels"},{"location":"channels/#send-key","text":"Value: SendKey Request Parameters { \"button_id\": \"button id string\", // optional: // \"device_id\": \"target device id\" } Response Parameters True on success, False on error","title":"Send Key"},{"location":"channels/#media-channel","text":"Get info about currently playing media and control the playback. Used messages: Media Controller Removed Media Command Media Command Result Media State","title":"Media Channel"},{"location":"channels/#text-channel","text":"Input Text whenever a text-dialog is shown on Xbox. Used messages: Title Text Configuration Title Text Input Title Text Selection System Text Configuration System Text Input System Text Acknowledge System Text Done","title":"Text Channel"},{"location":"channels/#broadcast-channel","text":"Initializing of Gamestreaming is done over this channel. Communication is completely JSON -based. Actual streaming is done over Nano . Messages actively sent from client to console: Gamestream Start Message Gamestream Stop Message The other messages are basically status messages sent from console to client.","title":"Broadcast Channel"},{"location":"channels/#how-to-start-gamestreaming","text":"Open the SystemBroadcast channel. Console sends a Gamestream Enabled Message . Check the field enabled if it's possible to use Gamestreaming (e.g. if it's activated). Send a Gamestream Start Message to the console. Console sends some Gamestream State Messages . Get the connection data from State: Initializing . Use Nano to connect to the console.","title":"How to start gamestreaming?"},{"location":"channels/#broadcast-message-type","text":"Type Value Sent by Start Gamestream 0x01 Client Stop Gamestream 0x02 Client Gamestream State 0x03 Console Gamestream Enabled 0x04 Console Gamestream Error 0x05 Console Telemetry 0x06 Console Preview Status 0x07 Console","title":"Broadcast Message Type"},{"location":"channels/#messages","text":"","title":"Messages"},{"location":"channels/#gamestream-start-message","text":"Type: 0x1 Direction: Client -> Console NOTE: Some values could be int or bool rather than string but the following example is the original format that gets sent from the original Windows 10 client { \"type\": 1, \"configuration\": { \"urcpType\": \"0\", \"urcpFixedRate\": \"-1\", \"urcpMaximumWindow\": \"1310720\", \"urcpMinimumRate\": \"256000\", \"urcpMaximumRate\": \"10000000\", \"urcpKeepAliveTimeoutMs\": \"0\", \"audioFecType\": \"0\", \"videoFecType\": \"0\", \"videoFecLevel\": \"3\", \"videoPacketUtilization\": \"0\", \"enableDynamicBitrate\": \"false\", \"dynamicBitrateScaleFactor\": \"1\", \"dynamicBitrateUpdateMs\": \"5000\", \"sendKeyframesOverTCP\": \"false\", \"videoMaximumWidth\": \"1280\", \"videoMaximumHeight\": \"720\", \"videoMaximumFrameRate\": \"60\", \"videoPacketDefragTimeoutMs\": \"16\", \"enableVideoFrameAcks\": \"false\", \"enableAudioChat\": \"true\", \"audioBufferLengthHns\": \"10000000\", \"audioSyncPolicy\": \"1\", \"audioSyncMinLatency\": \"10\", \"audioSyncDesiredLatency\": \"40\", \"audioSyncMaxLatency\": \"170\", \"audioSyncCompressLatency\": \"100\", \"audioSyncCompressFactor\": \"0.99\", \"audioSyncLengthenFactor\": \"1.01\", \"enableOpusAudio\": \"false\", \"enableOpusChatAudio\": \"true\", \"inputReadsPerSecond\": \"120\", \"udpMaxSendPacketsInWinsock\": \"250\", \"udpSubBurstGroups\": \"0\", \"udpBurstDurationMs\": \"12\" }, \"reQueryPreviewStatus\": false }","title":"Gamestream Start Message"},{"location":"channels/#gamestream-stop-message","text":"Type: 0x2 Direction: Client -> Console / never seen in the wild { \"type\": 2 }","title":"Gamestream Stop Message"},{"location":"channels/#gamestream-state-message","text":"Type: 0x3 Direction: Console -> Client All gamestream state messages use a state field, declared in the following table.","title":"Gamestream State Message"},{"location":"channels/#gamestream-state","text":"State Value Initializing 0x01 Started 0x02 Stopped 0x03 Paused 0x04","title":"Gamestream State"},{"location":"channels/#initializing","text":"{ \"type\": 3, \"state\": 1, \"sessionId\": \"{123E4567-E89b-12D3-A456-426655440000}\", \"udpPort\": 55068, \"tcpPort\": 52556 }","title":"Initializing"},{"location":"channels/#started","text":"{ \"type\": 3, \"state\": 2, \"sessionId\": \"{123E4567-E89b-12D3-A456-426655440000}\", \"isWirelessConnection\": false, \"wirelessChannel\": 0, \"transmitLinkSpeed\": 1000000000 }","title":"Started"},{"location":"channels/#stopped","text":"{ \"type\": 3, \"state\": 3, \"sessionId\": \"{123E4567-E89b-12D3-A456-426655440000}\" }","title":"Stopped"},{"location":"channels/#paused","text":"// Never seen in the wild","title":"Paused"},{"location":"channels/#gamestream-enabled-message","text":"Type: 0x4 Direction: Console -> Client { \"type\": 4, \"enabled\": true, \"canBeEnabled\": true, \"majorProtocolVersion\": 6, \"minorProtocolVersion\": 0 }","title":"Gamestream Enabled Message"},{"location":"channels/#gamestream-error-message","text":"Type: 0x5 Direction: Console -> Client { \"type\": 5, \"errorType\": 1, \"errorValue\": 1234 }","title":"Gamestream Error Message"},{"location":"channels/#gamestream-error","text":"Error Value General 0x01 Failed to instantiate 0x02 Failed to initialize 0x03 Failed to start 0x04 Failed to stop 0x05 No Controller 0x06 Different MSA active 0x07 DRM Video 0x08 HDCP Video 0x09 Kinect Title 0x0A Prohibited Game 0x0B Poor network connection 0x0C Streaming disabled 0x0D Cannot reach console 0x0E Generic Error 0x0F Version mismatch 0x10 No profile 0x11 Broadcast in progress 0x12","title":"Gamestream Error"},{"location":"channels/#gamestream-telemetry-message","text":"Type: 0x6 Direction: Unknown / never seen in the wild { \"type\": 6 }","title":"Gamestream Telemetry Message"},{"location":"channels/#gamestream-preview-status-message","text":"Type: 0x7 Direction: Console -> Client { \"type\": 7, \"isPublicPreview\": false, \"isInternalPreview\": false }","title":"Gamestream Preview Status Message"},{"location":"channels/#title-channel","text":"The title channel is used if the running title (aka. game) supports the SmartGlass Experience (for example: Fallout 4). For opening the Service Channel you have to send a Title Id while acquiring the channel . Title channel does basic communication over the Core channel : Auxiliary Stream Active Surface Change NOTE: For title specific data additional sockets are used!","title":"Title Channel"},{"location":"channels/#title-handshaking","text":"Flow to get connection data for title communication: Client sends Auxiliary Stream Handshake Host responds with Auxiliary Stream Handshake Client sends Auxiliary Stream Handshake again Host responds with Auxiliary Stream Connection Info Client sets up Auxiliary crypto context Client connects to advertised Title endpoints","title":"Title handshaking"},{"location":"channels/#packet-structure","text":"TODO","title":"Packet structure"},{"location":"cryptography/","text":"Cryptography Cryptography Key Exchange KDF Salts IV Generation Connect Request Messages Protected Payload Length Padding Example Message Authentication Auxiliary Stream encryption At a high level, SmartGlass uses: ECDH over prime256/384/521v1 with a salted SHA-512 KDF for key exchange AES-128-CBC for message encryption HMAC-SHA-256 for message authentication Key Exchange In detail, key exchange works like this: On Discovery, the console responds with a Discovery Response including a certificate, this certificate holds the console's public key. The client generates elliptic curve and derives the shared secret with console's public key using ECDH and a randomly generated public/private keypair The shared secret is salted using static salts, see KDF Salts The salted shared secret is hashed using SHA-512 The salted & hashed shared secret is split into the following individual keys: bytes 0-16 : Encryption key ( AES-128-CBC ) bytes 16-32 : Initialization Vector key ( AES-128-CBC ) bytes 32-64 : Hashing key ( HMAC-SHA-256 ) The client's public key is sent inside the Connect Request message to the console KDF Salts Prepend: D6 37 F1 AA E2 F0 41 8C Append: A8 F8 1A 57 4E 22 8A B7 IV Generation Connect Request The IV is randomly generated and transmitted inside the unprotected payload section of the Connect Request packet . Messages The IV is generated by encrypting the first 16 bytes of the packet header with AES-CBC-128 and a null IV. Protected Payload Length The protected payload length inside the header indicates the data length without padding. Padding Protected payloads are padded using out of specification PKCS#7 algorithm to match needed aligment for encryption. How it differs from specification : Plaintext needs to be aligned to 16 bytes. If the plaintext is 16 bytes aligned already, NO PADDING is used. NOTE: By specification, a whole padding block (16 bytes) would be appended to the plaintext. Example Plaintext (12 bytes) DE AD BE EF DE AD BE EF DE AD BE EF Padded (12+4 bytes) DE AD BE EF DE AD BE EF DE AD BE EF 04 04 04 04 As you can see, the padding consists of the count of bytes : 2 byte padding : 02 02 3 byte padding : 03 03 03 6 byte padding : 06 06 06 06 06 06 Message Authentication All encrypted packets are authenticated using HMAC-SHA-256 . The produced hash has a length of 32 bytes (0x20). Auxiliary Stream encryption Cryptography parameters for Title channel aka. Auxiliary Stream are transmitted via Auxiliary Stream message . The host sets all the crypto parameters and informs the client about it. Client then uses received AES key , HMAC key and Client/Server IV to setup the crypto context.","title":"Cryptography"},{"location":"cryptography/#cryptography","text":"Cryptography Key Exchange KDF Salts IV Generation Connect Request Messages Protected Payload Length Padding Example Message Authentication Auxiliary Stream encryption At a high level, SmartGlass uses: ECDH over prime256/384/521v1 with a salted SHA-512 KDF for key exchange AES-128-CBC for message encryption HMAC-SHA-256 for message authentication","title":"Cryptography"},{"location":"cryptography/#key-exchange","text":"In detail, key exchange works like this: On Discovery, the console responds with a Discovery Response including a certificate, this certificate holds the console's public key. The client generates elliptic curve and derives the shared secret with console's public key using ECDH and a randomly generated public/private keypair The shared secret is salted using static salts, see KDF Salts The salted shared secret is hashed using SHA-512 The salted & hashed shared secret is split into the following individual keys: bytes 0-16 : Encryption key ( AES-128-CBC ) bytes 16-32 : Initialization Vector key ( AES-128-CBC ) bytes 32-64 : Hashing key ( HMAC-SHA-256 ) The client's public key is sent inside the Connect Request message to the console","title":"Key Exchange"},{"location":"cryptography/#kdf-salts","text":"Prepend: D6 37 F1 AA E2 F0 41 8C Append: A8 F8 1A 57 4E 22 8A B7","title":"KDF Salts"},{"location":"cryptography/#iv-generation","text":"","title":"IV Generation"},{"location":"cryptography/#connect-request","text":"The IV is randomly generated and transmitted inside the unprotected payload section of the Connect Request packet .","title":"Connect Request"},{"location":"cryptography/#messages","text":"The IV is generated by encrypting the first 16 bytes of the packet header with AES-CBC-128 and a null IV.","title":"Messages"},{"location":"cryptography/#protected-payload-length","text":"The protected payload length inside the header indicates the data length without padding.","title":"Protected Payload Length"},{"location":"cryptography/#padding","text":"Protected payloads are padded using out of specification PKCS#7 algorithm to match needed aligment for encryption. How it differs from specification : Plaintext needs to be aligned to 16 bytes. If the plaintext is 16 bytes aligned already, NO PADDING is used. NOTE: By specification, a whole padding block (16 bytes) would be appended to the plaintext.","title":"Padding"},{"location":"cryptography/#example","text":"Plaintext (12 bytes) DE AD BE EF DE AD BE EF DE AD BE EF Padded (12+4 bytes) DE AD BE EF DE AD BE EF DE AD BE EF 04 04 04 04 As you can see, the padding consists of the count of bytes : 2 byte padding : 02 02 3 byte padding : 03 03 03 6 byte padding : 06 06 06 06 06 06","title":"Example"},{"location":"cryptography/#message-authentication","text":"All encrypted packets are authenticated using HMAC-SHA-256 . The produced hash has a length of 32 bytes (0x20).","title":"Message Authentication"},{"location":"cryptography/#auxiliary-stream-encryption","text":"Cryptography parameters for Title channel aka. Auxiliary Stream are transmitted via Auxiliary Stream message . The host sets all the crypto parameters and informs the client about it. Client then uses received AES key , HMAC key and Client/Server IV to setup the crypto context.","title":"Auxiliary Stream encryption"},{"location":"message/","text":"Message After the initial connection is made, the actual communication happens via packets of type 0xD00D . We refer to them as messages of type Message . Message Header Header Flags Message Types Message Payloads Local Join Device Capabilities Examples Channel Start Request Channel Start Response Channel Stop Console Status Active Title Active Title Location Active Surface Change Active Surface Type Fragment Acknowledgement Json Json Fragmentation Auxiliary Stream Endpoint Disconnect Disconnect Reason Power Off Game DVR Record Unsnap Gamepad Gamepad Button Paired Identity State Changed Paired Identity State Media State Sound Level Media Playback Status Media Transport State Media Type Media Metadata Media Controller Removed Media Command Result Media Command Media Control Command Orientation Compass Inclinometer Gyrometer Accelerometer Touch Touch Action Touchpoint Title Launch System Text Done Text Result System Text Acknowledge System Text Input Text Delta Title Text Selection Title Text Input Text Configuration Text Input Scope Text Option Flags Header Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Packet Type 0x02 2 uint16 Protected Payload Length 0x04 4 uint32 Sequence Number 0x08 8 uint32 Target Participant Id 0x0C 12 uint32 Source Participant Id 0x10 16 uint16 Flags (Version, NeedAck, IsFragment, MsgType) 0x12 18 uint64 Channel Id Packet Type : Always 0xD00D for message packet Protected Payload Length : Payload length before encryption excluding padding. That is, the length of the plaintext Sequence Number : Incrementing sequence number - if packet was not acknowledged even if requested, message gets sent again with same sequence number. Start index is 1 . Target Participant Id : Target Id as seen from sender, client sets this to 0 Source Participant Id : Id of sender, client gets that from Connect Response Flags : See Header Flags Channel Id : Negotioated Channel Id (see Channel Start Response ) Header Flags Flag Bits Mask Version 1100 0000 0000 0000 0xC000 Need Acknowledgement 0010 0000 0000 0000 0x2000 Is Fragment 0001 0000 0000 0000 0x1000 Message Type 0000 1111 1111 1111 0x0FFF Version : Always 2 Need Acknowledgement : Indicates if the message needs to be acknowledged by a message of type Acknowledgement Is Fragment : Indicates fragmented payload, see Fragment Message Type : See Message Types Message Types Direction as seen from the client perspective: \u2192 Sent from client to console \u2190 Sent from console to client \u2194 Both parties send this messagetype x Unknown Name Value Direction Channel Acknowledgement 0x01 \u2194 Various Group 0x02 x x Local Join 0x03 \u2192 Core Stop Activity 0x05 x x Auxiliary Stream 0x19 \u2194 Title Active Surface Change 0x1A \u2190 Title Navigate 0x1B x x Json 0x1C \u2194 Various Tunnel 0x1D x x Console Status 0x1E \u2190 Core Title Text Configuration 0x1F \u2190 SystemText Title Text Input 0x20 \u2194 SystemText Title Text Selection 0x21 \u2192 SystemText MirroringRequest 0x22 x x Title Launch 0x23 \u2192 Core Channel Start Request 0x26 \u2192 Core Channel Start Response 0x27 \u2190 Core Channel Stop 0x28 x Core System 0x29 x x Disconnect 0x2A \u2192 Core Title Touch 0x2E \u2192 SystemInput Accelerometer 0x2F \u2192 SystemInput Gyrometer 0x30 \u2192 SystemInput Inclinometer 0x31 \u2192 SystemInput Compass 0x32 \u2192 SystemInput Orientation 0x33 \u2192 SystemInput Paired Identity State Changed 0x36 \u2190 Core Unsnap 0x37 \u2192 Core Game DVR Record 0x38 \u2192 Core Power Off 0x39 \u2192 Core Media Controller Removed 0xF00 \u2190 SystemMedia Media Command 0xF01 \u2192 SystemMedia Media Command Result 0xF02 \u2190 SystemMedia Media State 0xF03 \u2190 SystemMedia Gamepad 0xF0A \u2192 SystemInput System Text Configuration 0xF2B \u2190 SystemText System Text Input 0xF2C \u2194 SystemText System Touch 0xF2E \u2192 SystemInput System Text Acknowledge 0xF34 \u2194 SystemText System Text Done 0xF35 \u2194 SystemText Message Payloads Local Join Message Type : 0x03 Response : None Requests Ack : YES Pair client to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Device Type 0x02 2 uint16 Native Width 0x04 4 uint16 Native Height 0x06 6 uint16 DPI X 0x08 8 uint16 DPI Y 0x0A 10 uint64 Device Capabilities 0x12 18 uint32 Client Version 0x16 22 uint32 OS Major Version 0x1A 26 uint32 OS Minor Version 0x1E 30 SGString Display Name Device Type : See Client Type Native Width : Display resolution width from connecting client Native Height : Display resolution height from connecting client DPI X : Pixel Density on X-axis from client display DPI Y : Pixel Density on Y-axis from client display Device Capabilities : See Device Capabilities Client Version : SmartGlass client version OS Major Version : Operating System major version OS Minor Version : Operating System minor version Display Name : Client's display name Device Capabilities Capability Bits Mask None 0000 0000 0000 0000 0x00 Streaming 0000 0000 0000 0001 0x01 Audio 0000 0000 0000 0010 0x02 Accelerometer 0000 0000 0000 0100 0x04 Compass 0000 0000 0000 1000 0x08 Gyrometer 0000 0000 0001 0000 0x10 Inclinometer 0000 0000 0010 0000 0x20 Orientation 0000 0000 0100 0000 0x40 All 1111 1111 1111 1111 0xFFFFFFFFFFFFFFFF Examples Windows DeviceType = ClientType.WindowsStore NativeWidth = 1080 NativeHeight = 1920 DpiX = 96 DpiY = 96 DeviceCapabilities = DeviceCapabilities.All ClientVersion = 15 OSMajor = 6 OSMinor = 2 DisplayName = \"SmartGlass-PC\" Android DeviceType = ClientType.Android # Resolution is portrait mode NativeWidth = 720 NativeHeight = 1280 DpiX = 160 DpiY = 160 DeviceCapabilities = DeviceCapabilities.All ClientVersion = 151117100 # v2.4.1511.17100-Beta OSMajor = 22 # Android 5.1.1 - API Version 22 OSMinor = 0 DisplayName = \"com.microsoft.xboxone.smartglass.beta\" Channel Start Request Message Type : 0x26 Response : Channel Start Response Requests Ack : NO Start opening a Service Channel . Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channel Request Id 0x04 4 uint32 Title Id 0x08 8 byte[16] Service Channel GUID 0x18 24 uint32 Activity Id Channel Request Id : Incrementing number, it's used to match with Channel Start Response Title Id : Set for Title channel , otherwise 0 Service Channel GUID : See Service Channels Activity Id : Always 0 Channel Start Response Message Type : 0x27 Response : None Requests Ack : NO Response to Channel Start Request . Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channel Request Id 0x04 4 uint64 Target Channel Id 0x0C 12 uint32 Result Channel Request Id : Matches with Channel Start Request Target Channel Id : Assigned Channel Id to be used in Message Header Result : Result code, 0 on success Channel Stop Message Type : 0x28 Response : None Requests Ack : NO Stop an opened Service Channel Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Target Channel Id Target Channel Id : Channel Id received by Channel Start Response Console Status Message Type : 0x1E Response : None Requests Ack : YES Informs client about running titles and Xbox OS version. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Live TV Provider 0x04 4 uint32 Major Version 0x08 8 uint32 Minor Version 0x0C 12 uint32 Build Number 0x10 16 SGString Locale 0x?? ? uint16 Active Title Count 0x?? ? ActiveTitle[count] Active Titles Live TV Provider : Live TV provider Id Major Version : Major OS version Minor Version : Minor OS version Build Number : OS builder number Locale : Locale string Active Title Count : Number of Active Titles Active Titles : Array of Active Title Active Title Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Title Id 0x04 4 uint16 Title Disposition 0x06 6 byte[16] Product Id 0x16 22 byte[16] Sandbox Id 0x26 38 SGString AUM Id Title Id : Title Id Title Disposition : 1 bit: HasFocus-Flag, 15 bits: Active Title Location Product Id : Product Id Sandbox Id : Sandbox Id AUM Id : Application User Model Id Active Title Location Location Value Full 0x00 Fill 0x01 Snapped 0x02 Start View 0x03 System UI 0x04 Default 0x05 Active Surface Change Message Type : 0x1A Response : None Requests Ack : NO Informs client about surface change, used in auxiliary-stream context. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Surface Type 0x02 2 uint16 Server TCP Port 0x04 4 uint16 Server UDP Port 0x06 6 byte[16] Session Id 0x16 22 uint16 Render Width 0x18 24 uint16 Render Height 0x1A 26 byte[16] Master Session Key Surface Type : See Active Surface Type Server TCP Port : Used with Auxiliary Stream Server UDP Port : Used with Auxiliary Stream Session Id : Used with Auxiliary Stream Render Width : Used with Auxiliary Stream Render Height : Used with Auxiliary Stream Master Session Key : Used with Auxiliary Stream Active Surface Type Type Value Blank 0x00 Direct 0x01 HTML 0x02 Title Text Entity 0x03 Fragment Message Type : variable Response : variable Requests Ack : variable Is Fragment : YES Used for messages that need to be fragmented. When all fragments are received, concatenate the data blobs and parse the assembled data as indicated Message Type . Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Sequence Begin 0x04 4 uint32 Sequence End 0x08 8 uint16 Data length 0x0A 10 byte[len] Data Sequence Begin : First sequence number of the fragment-set Sequence End : Last sequence number (+1) of the fragement-set Data : Data fragment Acknowledgement Message Type : 0x01 Response : None Requests Ack : NO Acknowledge a message from sender, alternatively used to request hearbeat from peer. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Low Watermark 0x04 4 uint32 Processed List Length 0x08 8 uint32[len] Processed List 0x?? ? uint32 Rejected List Length 0x?? ? uint32[len] Rejected List Low Watermark : Last received/processed sequence number Processed List : Processed sequence numbers (array of uint32 ) Rejected List : Rejected sequence numbers (array of uint32 ) Json Message Type : 0x1C Response : variable Requests Ack : variable Used to transfer commands or info in text-form. Offset (hex) Offset (dec) Type Description 0x00 0 SGString Text Text : JSON Body Json Fragmentation In case the Protected Payload of a Json Message exceeds 1024 bytes , the message gets fragmented. Fragmentation is done by base64-encoding and splitting-up the Json string, the maximum fragment length being 905 bytes (When serializing without spaces). Example fragment-set: # Fragment #0 {\"datagram_size\":\"24\",\"datagram_id\":\"1\",\"fragment_offset\":\"0\",\"fragment_length\":\"12\",\"fragment_data\":\"eyJ0ZXN0Ijoi\"} # Fragment #1 {\"datagram_size\":\"24\",\"datagram_id\":\"1\",\"fragment_offset\":\"12\",\"fragment_length\":\"12\",\"fragment_data\":\"dmFsdWUifQ==\"} # After concatenation \"eyJ0ZXN0IjoidmFsdWUifQ==\" # After decoding '{\"test\":\"value\"}' datagram_size : Total base64-string length datagram_id : Identifier of the fragment-set fragment_offset : Position of the current fragment fragment_length : Length of the current fragment fragment_data : Base64 string Receiving participant checks if a set of fragments is received completely by summarizing fragment_length fields for the specific datagram_id and checking it against datagram_size . When all fragments are received, they are ordered by fragment_offset and the fragment_data is concatenated and base64-decoded. Auxiliary Stream Message Type : 0x19 Response : None Requests Ack : YES Used for SmartGlass Experience aka. game companion stuff. The only known utilization is in Fallout 4. Offset (hex) Offset (dec) Type Description 0x00 0 byte Connection Info Flag If Connection Info Flag == 1: 0x01 1 uint16 AES Key length 0x03 3 byte[len] AES Key ?? ?? uint16 Server IV length ?? ?? byte[len] Server IV ?? ?? uint16 Client IV length ?? ?? byte[len] Client IV ?? ?? uint16 HMAC Key length ?? ?? byte[len] HMAC Key ?? ?? uint16 Endpoints Size ?? ?? Endpoint[size] Endpoints Connection Info Flag : Handshake: 0 , Connection Data: 1 AES Key : AES-CBC Key Server IV : Server's Initialization Vector Client IV : Client's Initialization Vector HMAC Key : HMAC key Endpoints Size : Endpoint count Endpoints : Advertised title endpoints, See Endpoint Endpoint Type Description SGString IP Address SGString Port Disconnect Message Type : 0x2A Response : None Requests Ack : NO Disconnect client from console. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Reason 0x04 4 uint32 Error code Reason : See Disconnect Reason Error code : Error code Disconnect Reason Reason Value Unspecified 0x00 Error 0x01 Power Off 0x02 Maintenance 0x03 AppClose 0x04 SignOut 0x05 Reboot 0x06 Disabled 0x07 Low Power 0x08 Power Off Message Type : 0x39 Response : None Requests Ack : NO Send poweroff to the console. Offset (hex) Offset (dec) Type Description 0x00 0 SGString Live ID Live ID : Live ID of console to power off. This info is stored in the Discovery Response Certificate Game DVR Record Message Type : 0x38 Response : None Requests Ack : YES Save a DVR clip Offset (hex) Offset (dec) Type Description 0x00 0 int32 Start Time Delta 0x04 4 int32 End Time Delta Start Time Delta : Start time of recording in seconds (e.g. -60 for last minute) End Time Delta : End time of recording in seconds (e.g. 0 for now ) Unsnap Message Type : 0x37 Response : None Requests Ack : NO Unsnap currently snapped application. Offset (hex) Offset (dec) Type Description 0x00 0 byte Unknown Unknown : Unknown Gamepad Message Type : 0xF0A Response : None Requests Ack : NO Send gamepad control (not for use with low latency gamestreaming ). Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 uint16 Buttons 0x0A 10 float32 Left Trigger 0x0E 14 float32 Right Trigger 0x12 18 float32 Left Thumbstick X 0x16 22 float32 Left Thumbstick Y 0x1A 26 float32 Right Thumbstick X 0x1E 30 float32 Right Thumbstick Y Timestamp : Timestamp Buttons : See Flags Gamepad Button Left Trigger : Left Trigger value Right Trigger : Right trigger value Left Thumbstick X : Left thumbstick x-axis value Left Thumbstick Y : Left thumbstick y-axis value Right Thumbstick X : Right thumbstick x-axis value Right Thumbstick Y : Right thumbstick y-axis value Gamepad Button Flag Bits Mask Clear 0000 0000 0000 0000 0x00 Enroll 0000 0000 0000 0001 0x01 Nexus 0000 0000 0000 0010 0x02 Menu 0000 0000 0000 0100 0x04 View 0000 0000 0000 1000 0x08 A 0000 0000 0001 0000 0x10 B 0000 0000 0010 0000 0x20 X 0000 0000 0100 0000 0x40 Y 0000 0000 1000 0000 0x080 D-Pad Up 0000 0001 0000 0000 0x100 D-Pad Down 0000 0010 0000 0000 0x200 D-Pad Left 0000 0100 0000 0000 0x400 D-Pad Right 0000 1000 0000 0000 0x800 Left Shoulder 0001 0000 0000 0000 0x1000 Right Shoulder 0010 0000 0000 0000 0x2000 Left Thumbstick 0100 0000 0000 0000 0x4000 Right Thumbstick 1000 0000 0000 0000 0x8000 Paired Identity State Changed Message Type : 0x36 Response : None Requests Ack : NO Informs client about paired identity state change. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 State State : See Paired Identity State Paired Identity State State Value Not Paired 0x00 Paired 0x01 Media State Message Type : 0xF03 Response : None Requests Ack : YES Informs client about media playback state. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Title Id 0x08 8 SGString AUM Id 0x0A 10 SGString Asset Id 0x0E 14 uint16 Media Type 0x12 18 uint16 Sound Level 0x16 22 uint32 Enabled commands 0x1A 26 uint32 Playback status 0x1E 30 float32 Rate 0x22 34 uint64 Position 0x2A 42 uint64 Media Start 0x32 50 uint64 Media End 0x38 58 uint64 Min Seek 0x42 66 uint64 Max Seek 0x4A 74 uint16 Metadata Length 0x4C 76 MediaMetadata[len] Metadata Title Id : Title Id of media AUM Id : Application User Model Id of media Asset Id : Asset Id Media Type : See Media Type Sound Level : See Sound Level Enabled commands : See Media Control Command Playback status : See Media Playback Status Rate : Playback rate Position : Current media position (nanoseconds) Media Start : Media start (nanoseconds) Media End : Media end (nanoseconds) Min Seek : Minimal seek position (nanoseconds) Max Seek : Maximal seek position (nanoseconds) Metadata Length : Length of Metadata array Metadata : Array of Media Metadata Sound Level Level Value Muted 0x00 Low 0x01 Full 0x02 Media Playback Status Status Value Closed 0x00 Changing 0x01 Stopped 0x02 Playing 0x03 Paused 0x04 Media Transport State State Value Invalid 0x00 Stopped 0x01 Starting 0x02 Playing 0x03 Paused 0x04 Buffering 0x05 Media Type Type Value NoMedia 0x00 Music 0x01 Video 0x02 Image 0x03 Conversation 0x04 Game 0x05 Media Metadata Offset (hex) Offset (dec) Type Description 0x00 0 SGString Name 0x?? ? SGString Value Media Controller Removed Message Type : 0xF00 Response : None Requests Ack : YES Informs client about removed media controller. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Title Id Title Id : Title Id of removed media controller Media Command Result Message Type : 0xF02 Response : None Requests Ack : YES Informs client wether Media Command succeeded. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Request Id 0x08 8 uint32 Result Request Id : Match with request Id of Media Command Result : Result, 0 is success Media Command Message Type : 0xF01 Response : Media Command Result Requests Ack : NO Sends media playback command to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Request Id 0x08 8 uint32 Title Id 0x0C 12 uint32 Command | If Command == Seek | 0x10 | 16 | uint32 | Seek position Request Id : Request Id Title Id : Title Id of media controller Command : See Media Control Command Seek position (optional) : Only set if Command == Seek Media Control Command Flag Bits Mask Play 0000 0000 0000 0010 0x02 Pause 0000 0000 0000 0100 0x04 Play Pause Toggle 0000 0000 0000 1000 0x08 Stop 0000 0000 0001 0000 0x10 Record 0000 0000 0010 0000 0x20 Next Track 0000 0000 0100 0000 0x40 Previous Track 0000 0000 1000 0000 0x080 Fast Forward 0000 0001 0000 0000 0x100 Rewind 0000 0010 0000 0000 0x200 Channel Up 0000 0100 0000 0000 0x400 Channel Down 0000 1000 0000 0000 0x800 Back 0001 0000 0000 0000 0x1000 View 0010 0000 0000 0000 0x2000 Menu 0100 0000 0000 0000 0x4000 Seek 1000 0000 0000 0000 0x8000 Orientation Message Type : 0x33 Response : None Requests Ack : NO Send orientation message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Rotation Matrix Value 0x0C 12 float32 W 0x10 16 float32 X 0x14 20 float32 Y 0x18 24 float32 Z Timestamp : Timestamp Rotation Matrix Value : Rotation Matrix Value W : Value of W-axis X : Value of X-axis Y : Value of Y-axis Z : Value of Z-axis Compass Message Type : 0x32 Response : None Requests Ack : NO Send compass message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Magnetic North 0x0C 12 float32 True North Timestamp : Timestamp Magnetic North : Magnetic North True North : True North Inclinometer Message Type : 0x31 Response : None Requests Ack : NO Send inclinometer message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Pitch 0x0C 12 float32 Roll 0x10 16 float32 Yaw Timestamp : Timestamp Pitch : Pitch Roll : Roll Yaw : Yaw Gyrometer Message Type : 0x30 Response : None Requests Ack : NO Send gyrometer message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Angular Velocity X 0x0C 12 float32 Angular Velocity Y 0x10 16 float32 Angular Velocity Z Timestamp : Timestamp Angular Velocity X : Angular Velocity X-axis Angular Velocity Y : Angular Velocity Y-axis Angular Velocity Z : Angular Velocity Z-axis Accelerometer Message Type : 0x Response : None Requests Ack : NO Send accelerometer message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Acceleration X 0x0C 12 float32 Acceleration Y 0x10 16 float32 Acceleration Z Timestamp : Timestamp Acceleration X : Acceleration X-axis Acceleration Y : Acceleration Y-axis Acceleration Z : Acceleration Z-axis Touch Message Type : 0x2E (Title) or 0xF2E (System) Response : None Requests Ack : NO Send touch input message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Touch Msg Timestamp 0x04 4 uint16 Touch Count 0x06 6 Touchpoint[count] Touches Touch Msg Timestamp : Timestamp Touch Count : Number of touchpoints Touches : Array of Touchpoint Touch Action Action Value Down 0x01 Move 0x02 Up 0x03 Cancel 0x04 Touchpoint Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Touchpoint Id 0x04 4 uint16 Touchpoint Action 0x06 6 uint32 Touchpoint X 0x0A 10 uint32 Touchpoint Y Touchpoint Id : Id of Touchpoint Touchpoint Action : See Touch Action Touchpoint X : Touchpoint X-Axis Touchpoint Y : Touchpoint X-Axis Title Launch Message Type : 0x23 Response : None Requests Ack : YES Launch a title / URL on the console. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Location 0x02 2 SGString Uri Location : Usually 0 Uri : Uri to launch System Text Done Message Type : 0xF35 Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Text Session Id 0x04 4 uint32 Text Version 0x08 8 uint32 Flags 0x0C 12 uint32 Result Text Session Id : Text session id Text Version : Text version Flags : Flags Result : See Text Result Text Result Result Value Cancel 0x00 Accept 0x01 System Text Acknowledge Message Type : 0xF34 Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Text Session Id 0x04 4 uint32 Text Version Ack Text Session Id : Text session id Text Version Ack : Text version to acknowledge System Text Input Message Type : 0xF2C Response : System Text Acknowledge Requests Ack : NO Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Text Session Id 0x04 4 uint32 Base Version 0x08 8 uint32 Submitted Version 0x0C 12 uint32 Total Text bytelength 0x10 16 uint32 Selection Start 0x14 20 uint32 Selection Length 0x18 24 uint16 Flags 0x1A 26 uint32 Text Chunk bytestart 0x1E 30 SGString Text Chunk 0x?? ?? uint16 Delta Length 0x?? ?? Delta[len] Text Delta Text Session Id : Text session id Base Version : Base version Submitted Version : Submitted version Total Text bytelength : Total bytelength of text Selection Start : Selection start Selection Length : Selection length Flags : Flags Text Chunk bytestart : Bytestart of textchunk Text Chunk : Actual text chunk to send Delta Length : Count of Text Delta Text Delta : See Text Delta Text Delta Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Offset 0x04 4 uint32 Delete Count 0x08 8 SGString Insert Content Title Text Selection Message Type : 0x21 Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Text Session Id 0x08 8 uint32 Text Buffer Version 0x0C 12 uint32 Start 0x10 16 uint32 Length Text Session Id : Text session id Text Buffer Version : Text buffer version Start : Start Length : Length Title Text Input Message Type : 0x Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Text Session Id 0x08 8 uint32 Text Buffer Version 0x0C 12 uint16 Result 0x0E 14 SGString Text Text Session Id : Text session id Text Buffer Version : Text buffer version Result : See Text Result Text : Actual text Text Configuration Message Type : 0x1F (Title) or 0xF2B (System) Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Text Session Id 0x08 8 uint32 Text Buffer Version 0x0C 12 uint32 Text options 0x10 16 uint32 Input Scope 0x14 20 uint32 Max Text Length 0x18 24 SGString Locale 0x?? ?? SGString Prompt Text Session Id : Text session id Text Buffer Version : Text buffer version Text options : See Text Option Flags Input Scope : See Text Input Scope Max Text Length : Maximal text length Locale : Locale to use Prompt : Text input prompt Text Input Scope Scope Value Default 0x0 Url 0x1 Full FilePath 0x2 File Name 0x3 Email UserName 0x4 Email SmtpAddress 0x5 LogOn Name 0x6 Personal FullName 0x7 Personal NamePrefix 0x8 Personal GivenName 0x9 Personal MiddleName 0xA Personal Surname 0xB Personal NameSuffix 0xC Postal Address 0xD Postal Code 0xE Address Street 0xF Address StateOrProvince 0x10 Address City 0x11 Address CountryName 0x12 Address CountryShortName 0x13 Currency AmountAndSymbol 0x14 Currency Amount 0x15 Date 0x16 Date Month 0x17 Date Day 0x18 Date Year 0x19 Date MonthName 0x1A Date DayName 0x1B Digits 0x1C Number 0x1D OneChar 0x1E Password 0x1F Telephone Number 0x20 Telephone CountryCode 0x21 Telephone AreaCode 0x22 Telephone LocalNumber 0x23 Time 0x24 Time Hour 0x25 Time MinorSec 0x26 Number FullWidth 0x27 Alphanumeric HalfWidth 0x28 Alphanumeric FullWidth 0x29 Currency Chinese 0x2A Bopomofo 0x2B Hiragana 0x2C Katakana HalfWidth 0x2D Katakana FullWidth 0x2E Hanja 0x2F Hangul HalfWidth 0x30 Hangul FullWidth 0x31 Search 0x32 Search TitleText 0x33 Search Incremental 0x34 Chinese HalfWidth 0x35 Chinese FullWidth 0x36 NativeScript 0x37 Text Option Flags Flag Bits Mask Default 0000 0000 0000 0000 0x00 Accepts Return 0000 0000 0000 0001 0x01 Password 0000 0000 0000 0010 0x02 Multi Line 0000 0000 0000 0100 0x04 Spell Check Enabled 0000 0000 0000 1000 0x08 Prediction Enabled 0000 0000 0001 0000 0x10 RTL 0000 0000 0010 0000 0x20 Dismiss 0100 0000 0000 0000 0x4000","title":"Messages"},{"location":"message/#message","text":"After the initial connection is made, the actual communication happens via packets of type 0xD00D . We refer to them as messages of type Message . Message Header Header Flags Message Types Message Payloads Local Join Device Capabilities Examples Channel Start Request Channel Start Response Channel Stop Console Status Active Title Active Title Location Active Surface Change Active Surface Type Fragment Acknowledgement Json Json Fragmentation Auxiliary Stream Endpoint Disconnect Disconnect Reason Power Off Game DVR Record Unsnap Gamepad Gamepad Button Paired Identity State Changed Paired Identity State Media State Sound Level Media Playback Status Media Transport State Media Type Media Metadata Media Controller Removed Media Command Result Media Command Media Control Command Orientation Compass Inclinometer Gyrometer Accelerometer Touch Touch Action Touchpoint Title Launch System Text Done Text Result System Text Acknowledge System Text Input Text Delta Title Text Selection Title Text Input Text Configuration Text Input Scope Text Option Flags","title":"Message"},{"location":"message/#header","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Packet Type 0x02 2 uint16 Protected Payload Length 0x04 4 uint32 Sequence Number 0x08 8 uint32 Target Participant Id 0x0C 12 uint32 Source Participant Id 0x10 16 uint16 Flags (Version, NeedAck, IsFragment, MsgType) 0x12 18 uint64 Channel Id Packet Type : Always 0xD00D for message packet Protected Payload Length : Payload length before encryption excluding padding. That is, the length of the plaintext Sequence Number : Incrementing sequence number - if packet was not acknowledged even if requested, message gets sent again with same sequence number. Start index is 1 . Target Participant Id : Target Id as seen from sender, client sets this to 0 Source Participant Id : Id of sender, client gets that from Connect Response Flags : See Header Flags Channel Id : Negotioated Channel Id (see Channel Start Response )","title":"Header"},{"location":"message/#header-flags","text":"Flag Bits Mask Version 1100 0000 0000 0000 0xC000 Need Acknowledgement 0010 0000 0000 0000 0x2000 Is Fragment 0001 0000 0000 0000 0x1000 Message Type 0000 1111 1111 1111 0x0FFF Version : Always 2 Need Acknowledgement : Indicates if the message needs to be acknowledged by a message of type Acknowledgement Is Fragment : Indicates fragmented payload, see Fragment Message Type : See Message Types","title":"Header Flags"},{"location":"message/#message-types","text":"Direction as seen from the client perspective: \u2192 Sent from client to console \u2190 Sent from console to client \u2194 Both parties send this messagetype x Unknown Name Value Direction Channel Acknowledgement 0x01 \u2194 Various Group 0x02 x x Local Join 0x03 \u2192 Core Stop Activity 0x05 x x Auxiliary Stream 0x19 \u2194 Title Active Surface Change 0x1A \u2190 Title Navigate 0x1B x x Json 0x1C \u2194 Various Tunnel 0x1D x x Console Status 0x1E \u2190 Core Title Text Configuration 0x1F \u2190 SystemText Title Text Input 0x20 \u2194 SystemText Title Text Selection 0x21 \u2192 SystemText MirroringRequest 0x22 x x Title Launch 0x23 \u2192 Core Channel Start Request 0x26 \u2192 Core Channel Start Response 0x27 \u2190 Core Channel Stop 0x28 x Core System 0x29 x x Disconnect 0x2A \u2192 Core Title Touch 0x2E \u2192 SystemInput Accelerometer 0x2F \u2192 SystemInput Gyrometer 0x30 \u2192 SystemInput Inclinometer 0x31 \u2192 SystemInput Compass 0x32 \u2192 SystemInput Orientation 0x33 \u2192 SystemInput Paired Identity State Changed 0x36 \u2190 Core Unsnap 0x37 \u2192 Core Game DVR Record 0x38 \u2192 Core Power Off 0x39 \u2192 Core Media Controller Removed 0xF00 \u2190 SystemMedia Media Command 0xF01 \u2192 SystemMedia Media Command Result 0xF02 \u2190 SystemMedia Media State 0xF03 \u2190 SystemMedia Gamepad 0xF0A \u2192 SystemInput System Text Configuration 0xF2B \u2190 SystemText System Text Input 0xF2C \u2194 SystemText System Touch 0xF2E \u2192 SystemInput System Text Acknowledge 0xF34 \u2194 SystemText System Text Done 0xF35 \u2194 SystemText","title":"Message Types"},{"location":"message/#message-payloads","text":"","title":"Message Payloads"},{"location":"message/#local-join","text":"Message Type : 0x03 Response : None Requests Ack : YES Pair client to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Device Type 0x02 2 uint16 Native Width 0x04 4 uint16 Native Height 0x06 6 uint16 DPI X 0x08 8 uint16 DPI Y 0x0A 10 uint64 Device Capabilities 0x12 18 uint32 Client Version 0x16 22 uint32 OS Major Version 0x1A 26 uint32 OS Minor Version 0x1E 30 SGString Display Name Device Type : See Client Type Native Width : Display resolution width from connecting client Native Height : Display resolution height from connecting client DPI X : Pixel Density on X-axis from client display DPI Y : Pixel Density on Y-axis from client display Device Capabilities : See Device Capabilities Client Version : SmartGlass client version OS Major Version : Operating System major version OS Minor Version : Operating System minor version Display Name : Client's display name","title":"Local Join"},{"location":"message/#device-capabilities","text":"Capability Bits Mask None 0000 0000 0000 0000 0x00 Streaming 0000 0000 0000 0001 0x01 Audio 0000 0000 0000 0010 0x02 Accelerometer 0000 0000 0000 0100 0x04 Compass 0000 0000 0000 1000 0x08 Gyrometer 0000 0000 0001 0000 0x10 Inclinometer 0000 0000 0010 0000 0x20 Orientation 0000 0000 0100 0000 0x40 All 1111 1111 1111 1111 0xFFFFFFFFFFFFFFFF","title":"Device Capabilities"},{"location":"message/#examples","text":"Windows DeviceType = ClientType.WindowsStore NativeWidth = 1080 NativeHeight = 1920 DpiX = 96 DpiY = 96 DeviceCapabilities = DeviceCapabilities.All ClientVersion = 15 OSMajor = 6 OSMinor = 2 DisplayName = \"SmartGlass-PC\" Android DeviceType = ClientType.Android # Resolution is portrait mode NativeWidth = 720 NativeHeight = 1280 DpiX = 160 DpiY = 160 DeviceCapabilities = DeviceCapabilities.All ClientVersion = 151117100 # v2.4.1511.17100-Beta OSMajor = 22 # Android 5.1.1 - API Version 22 OSMinor = 0 DisplayName = \"com.microsoft.xboxone.smartglass.beta\"","title":"Examples"},{"location":"message/#channel-start-request","text":"Message Type : 0x26 Response : Channel Start Response Requests Ack : NO Start opening a Service Channel . Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channel Request Id 0x04 4 uint32 Title Id 0x08 8 byte[16] Service Channel GUID 0x18 24 uint32 Activity Id Channel Request Id : Incrementing number, it's used to match with Channel Start Response Title Id : Set for Title channel , otherwise 0 Service Channel GUID : See Service Channels Activity Id : Always 0","title":"Channel Start Request"},{"location":"message/#channel-start-response","text":"Message Type : 0x27 Response : None Requests Ack : NO Response to Channel Start Request . Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channel Request Id 0x04 4 uint64 Target Channel Id 0x0C 12 uint32 Result Channel Request Id : Matches with Channel Start Request Target Channel Id : Assigned Channel Id to be used in Message Header Result : Result code, 0 on success","title":"Channel Start Response"},{"location":"message/#channel-stop","text":"Message Type : 0x28 Response : None Requests Ack : NO Stop an opened Service Channel Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Target Channel Id Target Channel Id : Channel Id received by Channel Start Response","title":"Channel Stop"},{"location":"message/#console-status","text":"Message Type : 0x1E Response : None Requests Ack : YES Informs client about running titles and Xbox OS version. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Live TV Provider 0x04 4 uint32 Major Version 0x08 8 uint32 Minor Version 0x0C 12 uint32 Build Number 0x10 16 SGString Locale 0x?? ? uint16 Active Title Count 0x?? ? ActiveTitle[count] Active Titles Live TV Provider : Live TV provider Id Major Version : Major OS version Minor Version : Minor OS version Build Number : OS builder number Locale : Locale string Active Title Count : Number of Active Titles Active Titles : Array of Active Title","title":"Console Status"},{"location":"message/#active-title","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Title Id 0x04 4 uint16 Title Disposition 0x06 6 byte[16] Product Id 0x16 22 byte[16] Sandbox Id 0x26 38 SGString AUM Id Title Id : Title Id Title Disposition : 1 bit: HasFocus-Flag, 15 bits: Active Title Location Product Id : Product Id Sandbox Id : Sandbox Id AUM Id : Application User Model Id","title":"Active Title"},{"location":"message/#active-title-location","text":"Location Value Full 0x00 Fill 0x01 Snapped 0x02 Start View 0x03 System UI 0x04 Default 0x05","title":"Active Title Location"},{"location":"message/#active-surface-change","text":"Message Type : 0x1A Response : None Requests Ack : NO Informs client about surface change, used in auxiliary-stream context. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Surface Type 0x02 2 uint16 Server TCP Port 0x04 4 uint16 Server UDP Port 0x06 6 byte[16] Session Id 0x16 22 uint16 Render Width 0x18 24 uint16 Render Height 0x1A 26 byte[16] Master Session Key Surface Type : See Active Surface Type Server TCP Port : Used with Auxiliary Stream Server UDP Port : Used with Auxiliary Stream Session Id : Used with Auxiliary Stream Render Width : Used with Auxiliary Stream Render Height : Used with Auxiliary Stream Master Session Key : Used with Auxiliary Stream","title":"Active Surface Change"},{"location":"message/#active-surface-type","text":"Type Value Blank 0x00 Direct 0x01 HTML 0x02 Title Text Entity 0x03","title":"Active Surface Type"},{"location":"message/#fragment","text":"Message Type : variable Response : variable Requests Ack : variable Is Fragment : YES Used for messages that need to be fragmented. When all fragments are received, concatenate the data blobs and parse the assembled data as indicated Message Type . Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Sequence Begin 0x04 4 uint32 Sequence End 0x08 8 uint16 Data length 0x0A 10 byte[len] Data Sequence Begin : First sequence number of the fragment-set Sequence End : Last sequence number (+1) of the fragement-set Data : Data fragment","title":"Fragment"},{"location":"message/#acknowledgement","text":"Message Type : 0x01 Response : None Requests Ack : NO Acknowledge a message from sender, alternatively used to request hearbeat from peer. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Low Watermark 0x04 4 uint32 Processed List Length 0x08 8 uint32[len] Processed List 0x?? ? uint32 Rejected List Length 0x?? ? uint32[len] Rejected List Low Watermark : Last received/processed sequence number Processed List : Processed sequence numbers (array of uint32 ) Rejected List : Rejected sequence numbers (array of uint32 )","title":"Acknowledgement"},{"location":"message/#json","text":"Message Type : 0x1C Response : variable Requests Ack : variable Used to transfer commands or info in text-form. Offset (hex) Offset (dec) Type Description 0x00 0 SGString Text Text : JSON Body","title":"Json"},{"location":"message/#json-fragmentation","text":"In case the Protected Payload of a Json Message exceeds 1024 bytes , the message gets fragmented. Fragmentation is done by base64-encoding and splitting-up the Json string, the maximum fragment length being 905 bytes (When serializing without spaces). Example fragment-set: # Fragment #0 {\"datagram_size\":\"24\",\"datagram_id\":\"1\",\"fragment_offset\":\"0\",\"fragment_length\":\"12\",\"fragment_data\":\"eyJ0ZXN0Ijoi\"} # Fragment #1 {\"datagram_size\":\"24\",\"datagram_id\":\"1\",\"fragment_offset\":\"12\",\"fragment_length\":\"12\",\"fragment_data\":\"dmFsdWUifQ==\"} # After concatenation \"eyJ0ZXN0IjoidmFsdWUifQ==\" # After decoding '{\"test\":\"value\"}' datagram_size : Total base64-string length datagram_id : Identifier of the fragment-set fragment_offset : Position of the current fragment fragment_length : Length of the current fragment fragment_data : Base64 string Receiving participant checks if a set of fragments is received completely by summarizing fragment_length fields for the specific datagram_id and checking it against datagram_size . When all fragments are received, they are ordered by fragment_offset and the fragment_data is concatenated and base64-decoded.","title":"Json Fragmentation"},{"location":"message/#auxiliary-stream","text":"Message Type : 0x19 Response : None Requests Ack : YES Used for SmartGlass Experience aka. game companion stuff. The only known utilization is in Fallout 4. Offset (hex) Offset (dec) Type Description 0x00 0 byte Connection Info Flag If Connection Info Flag == 1: 0x01 1 uint16 AES Key length 0x03 3 byte[len] AES Key ?? ?? uint16 Server IV length ?? ?? byte[len] Server IV ?? ?? uint16 Client IV length ?? ?? byte[len] Client IV ?? ?? uint16 HMAC Key length ?? ?? byte[len] HMAC Key ?? ?? uint16 Endpoints Size ?? ?? Endpoint[size] Endpoints Connection Info Flag : Handshake: 0 , Connection Data: 1 AES Key : AES-CBC Key Server IV : Server's Initialization Vector Client IV : Client's Initialization Vector HMAC Key : HMAC key Endpoints Size : Endpoint count Endpoints : Advertised title endpoints, See Endpoint","title":"Auxiliary Stream"},{"location":"message/#endpoint","text":"Type Description SGString IP Address SGString Port","title":"Endpoint"},{"location":"message/#disconnect","text":"Message Type : 0x2A Response : None Requests Ack : NO Disconnect client from console. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Reason 0x04 4 uint32 Error code Reason : See Disconnect Reason Error code : Error code","title":"Disconnect"},{"location":"message/#disconnect-reason","text":"Reason Value Unspecified 0x00 Error 0x01 Power Off 0x02 Maintenance 0x03 AppClose 0x04 SignOut 0x05 Reboot 0x06 Disabled 0x07 Low Power 0x08","title":"Disconnect Reason"},{"location":"message/#power-off","text":"Message Type : 0x39 Response : None Requests Ack : NO Send poweroff to the console. Offset (hex) Offset (dec) Type Description 0x00 0 SGString Live ID Live ID : Live ID of console to power off. This info is stored in the Discovery Response Certificate","title":"Power Off"},{"location":"message/#game-dvr-record","text":"Message Type : 0x38 Response : None Requests Ack : YES Save a DVR clip Offset (hex) Offset (dec) Type Description 0x00 0 int32 Start Time Delta 0x04 4 int32 End Time Delta Start Time Delta : Start time of recording in seconds (e.g. -60 for last minute) End Time Delta : End time of recording in seconds (e.g. 0 for now )","title":"Game DVR Record"},{"location":"message/#unsnap","text":"Message Type : 0x37 Response : None Requests Ack : NO Unsnap currently snapped application. Offset (hex) Offset (dec) Type Description 0x00 0 byte Unknown Unknown : Unknown","title":"Unsnap"},{"location":"message/#gamepad","text":"Message Type : 0xF0A Response : None Requests Ack : NO Send gamepad control (not for use with low latency gamestreaming ). Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 uint16 Buttons 0x0A 10 float32 Left Trigger 0x0E 14 float32 Right Trigger 0x12 18 float32 Left Thumbstick X 0x16 22 float32 Left Thumbstick Y 0x1A 26 float32 Right Thumbstick X 0x1E 30 float32 Right Thumbstick Y Timestamp : Timestamp Buttons : See Flags Gamepad Button Left Trigger : Left Trigger value Right Trigger : Right trigger value Left Thumbstick X : Left thumbstick x-axis value Left Thumbstick Y : Left thumbstick y-axis value Right Thumbstick X : Right thumbstick x-axis value Right Thumbstick Y : Right thumbstick y-axis value","title":"Gamepad"},{"location":"message/#gamepad-button","text":"Flag Bits Mask Clear 0000 0000 0000 0000 0x00 Enroll 0000 0000 0000 0001 0x01 Nexus 0000 0000 0000 0010 0x02 Menu 0000 0000 0000 0100 0x04 View 0000 0000 0000 1000 0x08 A 0000 0000 0001 0000 0x10 B 0000 0000 0010 0000 0x20 X 0000 0000 0100 0000 0x40 Y 0000 0000 1000 0000 0x080 D-Pad Up 0000 0001 0000 0000 0x100 D-Pad Down 0000 0010 0000 0000 0x200 D-Pad Left 0000 0100 0000 0000 0x400 D-Pad Right 0000 1000 0000 0000 0x800 Left Shoulder 0001 0000 0000 0000 0x1000 Right Shoulder 0010 0000 0000 0000 0x2000 Left Thumbstick 0100 0000 0000 0000 0x4000 Right Thumbstick 1000 0000 0000 0000 0x8000","title":"Gamepad Button"},{"location":"message/#paired-identity-state-changed","text":"Message Type : 0x36 Response : None Requests Ack : NO Informs client about paired identity state change. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 State State : See Paired Identity State","title":"Paired Identity State Changed"},{"location":"message/#paired-identity-state","text":"State Value Not Paired 0x00 Paired 0x01","title":"Paired Identity State"},{"location":"message/#media-state","text":"Message Type : 0xF03 Response : None Requests Ack : YES Informs client about media playback state. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Title Id 0x08 8 SGString AUM Id 0x0A 10 SGString Asset Id 0x0E 14 uint16 Media Type 0x12 18 uint16 Sound Level 0x16 22 uint32 Enabled commands 0x1A 26 uint32 Playback status 0x1E 30 float32 Rate 0x22 34 uint64 Position 0x2A 42 uint64 Media Start 0x32 50 uint64 Media End 0x38 58 uint64 Min Seek 0x42 66 uint64 Max Seek 0x4A 74 uint16 Metadata Length 0x4C 76 MediaMetadata[len] Metadata Title Id : Title Id of media AUM Id : Application User Model Id of media Asset Id : Asset Id Media Type : See Media Type Sound Level : See Sound Level Enabled commands : See Media Control Command Playback status : See Media Playback Status Rate : Playback rate Position : Current media position (nanoseconds) Media Start : Media start (nanoseconds) Media End : Media end (nanoseconds) Min Seek : Minimal seek position (nanoseconds) Max Seek : Maximal seek position (nanoseconds) Metadata Length : Length of Metadata array Metadata : Array of Media Metadata","title":"Media State"},{"location":"message/#sound-level","text":"Level Value Muted 0x00 Low 0x01 Full 0x02","title":"Sound Level"},{"location":"message/#media-playback-status","text":"Status Value Closed 0x00 Changing 0x01 Stopped 0x02 Playing 0x03 Paused 0x04","title":"Media Playback Status"},{"location":"message/#media-transport-state","text":"State Value Invalid 0x00 Stopped 0x01 Starting 0x02 Playing 0x03 Paused 0x04 Buffering 0x05","title":"Media Transport State"},{"location":"message/#media-type","text":"Type Value NoMedia 0x00 Music 0x01 Video 0x02 Image 0x03 Conversation 0x04 Game 0x05","title":"Media Type"},{"location":"message/#media-metadata","text":"Offset (hex) Offset (dec) Type Description 0x00 0 SGString Name 0x?? ? SGString Value","title":"Media Metadata"},{"location":"message/#media-controller-removed","text":"Message Type : 0xF00 Response : None Requests Ack : YES Informs client about removed media controller. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Title Id Title Id : Title Id of removed media controller","title":"Media Controller Removed"},{"location":"message/#media-command-result","text":"Message Type : 0xF02 Response : None Requests Ack : YES Informs client wether Media Command succeeded. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Request Id 0x08 8 uint32 Result Request Id : Match with request Id of Media Command Result : Result, 0 is success","title":"Media Command Result"},{"location":"message/#media-command","text":"Message Type : 0xF01 Response : Media Command Result Requests Ack : NO Sends media playback command to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Request Id 0x08 8 uint32 Title Id 0x0C 12 uint32 Command | If Command == Seek | 0x10 | 16 | uint32 | Seek position Request Id : Request Id Title Id : Title Id of media controller Command : See Media Control Command Seek position (optional) : Only set if Command == Seek","title":"Media Command"},{"location":"message/#media-control-command","text":"Flag Bits Mask Play 0000 0000 0000 0010 0x02 Pause 0000 0000 0000 0100 0x04 Play Pause Toggle 0000 0000 0000 1000 0x08 Stop 0000 0000 0001 0000 0x10 Record 0000 0000 0010 0000 0x20 Next Track 0000 0000 0100 0000 0x40 Previous Track 0000 0000 1000 0000 0x080 Fast Forward 0000 0001 0000 0000 0x100 Rewind 0000 0010 0000 0000 0x200 Channel Up 0000 0100 0000 0000 0x400 Channel Down 0000 1000 0000 0000 0x800 Back 0001 0000 0000 0000 0x1000 View 0010 0000 0000 0000 0x2000 Menu 0100 0000 0000 0000 0x4000 Seek 1000 0000 0000 0000 0x8000","title":"Media Control Command"},{"location":"message/#orientation","text":"Message Type : 0x33 Response : None Requests Ack : NO Send orientation message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Rotation Matrix Value 0x0C 12 float32 W 0x10 16 float32 X 0x14 20 float32 Y 0x18 24 float32 Z Timestamp : Timestamp Rotation Matrix Value : Rotation Matrix Value W : Value of W-axis X : Value of X-axis Y : Value of Y-axis Z : Value of Z-axis","title":"Orientation"},{"location":"message/#compass","text":"Message Type : 0x32 Response : None Requests Ack : NO Send compass message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Magnetic North 0x0C 12 float32 True North Timestamp : Timestamp Magnetic North : Magnetic North True North : True North","title":"Compass"},{"location":"message/#inclinometer","text":"Message Type : 0x31 Response : None Requests Ack : NO Send inclinometer message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Pitch 0x0C 12 float32 Roll 0x10 16 float32 Yaw Timestamp : Timestamp Pitch : Pitch Roll : Roll Yaw : Yaw","title":"Inclinometer"},{"location":"message/#gyrometer","text":"Message Type : 0x30 Response : None Requests Ack : NO Send gyrometer message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Angular Velocity X 0x0C 12 float32 Angular Velocity Y 0x10 16 float32 Angular Velocity Z Timestamp : Timestamp Angular Velocity X : Angular Velocity X-axis Angular Velocity Y : Angular Velocity Y-axis Angular Velocity Z : Angular Velocity Z-axis","title":"Gyrometer"},{"location":"message/#accelerometer","text":"Message Type : 0x Response : None Requests Ack : NO Send accelerometer message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Timestamp 0x08 8 float32 Acceleration X 0x0C 12 float32 Acceleration Y 0x10 16 float32 Acceleration Z Timestamp : Timestamp Acceleration X : Acceleration X-axis Acceleration Y : Acceleration Y-axis Acceleration Z : Acceleration Z-axis","title":"Accelerometer"},{"location":"message/#touch","text":"Message Type : 0x2E (Title) or 0xF2E (System) Response : None Requests Ack : NO Send touch input message to console. Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Touch Msg Timestamp 0x04 4 uint16 Touch Count 0x06 6 Touchpoint[count] Touches Touch Msg Timestamp : Timestamp Touch Count : Number of touchpoints Touches : Array of Touchpoint","title":"Touch"},{"location":"message/#touch-action","text":"Action Value Down 0x01 Move 0x02 Up 0x03 Cancel 0x04","title":"Touch Action"},{"location":"message/#touchpoint","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Touchpoint Id 0x04 4 uint16 Touchpoint Action 0x06 6 uint32 Touchpoint X 0x0A 10 uint32 Touchpoint Y Touchpoint Id : Id of Touchpoint Touchpoint Action : See Touch Action Touchpoint X : Touchpoint X-Axis Touchpoint Y : Touchpoint X-Axis","title":"Touchpoint"},{"location":"message/#title-launch","text":"Message Type : 0x23 Response : None Requests Ack : YES Launch a title / URL on the console. Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Location 0x02 2 SGString Uri Location : Usually 0 Uri : Uri to launch","title":"Title Launch"},{"location":"message/#system-text-done","text":"Message Type : 0xF35 Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Text Session Id 0x04 4 uint32 Text Version 0x08 8 uint32 Flags 0x0C 12 uint32 Result Text Session Id : Text session id Text Version : Text version Flags : Flags Result : See Text Result","title":"System Text Done"},{"location":"message/#text-result","text":"Result Value Cancel 0x00 Accept 0x01","title":"Text Result"},{"location":"message/#system-text-acknowledge","text":"Message Type : 0xF34 Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Text Session Id 0x04 4 uint32 Text Version Ack Text Session Id : Text session id Text Version Ack : Text version to acknowledge","title":"System Text Acknowledge"},{"location":"message/#system-text-input","text":"Message Type : 0xF2C Response : System Text Acknowledge Requests Ack : NO Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Text Session Id 0x04 4 uint32 Base Version 0x08 8 uint32 Submitted Version 0x0C 12 uint32 Total Text bytelength 0x10 16 uint32 Selection Start 0x14 20 uint32 Selection Length 0x18 24 uint16 Flags 0x1A 26 uint32 Text Chunk bytestart 0x1E 30 SGString Text Chunk 0x?? ?? uint16 Delta Length 0x?? ?? Delta[len] Text Delta Text Session Id : Text session id Base Version : Base version Submitted Version : Submitted version Total Text bytelength : Total bytelength of text Selection Start : Selection start Selection Length : Selection length Flags : Flags Text Chunk bytestart : Bytestart of textchunk Text Chunk : Actual text chunk to send Delta Length : Count of Text Delta Text Delta : See Text Delta","title":"System Text Input"},{"location":"message/#text-delta","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Offset 0x04 4 uint32 Delete Count 0x08 8 SGString Insert Content","title":"Text Delta"},{"location":"message/#title-text-selection","text":"Message Type : 0x21 Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Text Session Id 0x08 8 uint32 Text Buffer Version 0x0C 12 uint32 Start 0x10 16 uint32 Length Text Session Id : Text session id Text Buffer Version : Text buffer version Start : Start Length : Length","title":"Title Text Selection"},{"location":"message/#title-text-input","text":"Message Type : 0x Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Text Session Id 0x08 8 uint32 Text Buffer Version 0x0C 12 uint16 Result 0x0E 14 SGString Text Text Session Id : Text session id Text Buffer Version : Text buffer version Result : See Text Result Text : Actual text","title":"Title Text Input"},{"location":"message/#text-configuration","text":"Message Type : 0x1F (Title) or 0xF2B (System) Response : None Requests Ack : YES Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Text Session Id 0x08 8 uint32 Text Buffer Version 0x0C 12 uint32 Text options 0x10 16 uint32 Input Scope 0x14 20 uint32 Max Text Length 0x18 24 SGString Locale 0x?? ?? SGString Prompt Text Session Id : Text session id Text Buffer Version : Text buffer version Text options : See Text Option Flags Input Scope : See Text Input Scope Max Text Length : Maximal text length Locale : Locale to use Prompt : Text input prompt","title":"Text Configuration"},{"location":"message/#text-input-scope","text":"Scope Value Default 0x0 Url 0x1 Full FilePath 0x2 File Name 0x3 Email UserName 0x4 Email SmtpAddress 0x5 LogOn Name 0x6 Personal FullName 0x7 Personal NamePrefix 0x8 Personal GivenName 0x9 Personal MiddleName 0xA Personal Surname 0xB Personal NameSuffix 0xC Postal Address 0xD Postal Code 0xE Address Street 0xF Address StateOrProvince 0x10 Address City 0x11 Address CountryName 0x12 Address CountryShortName 0x13 Currency AmountAndSymbol 0x14 Currency Amount 0x15 Date 0x16 Date Month 0x17 Date Day 0x18 Date Year 0x19 Date MonthName 0x1A Date DayName 0x1B Digits 0x1C Number 0x1D OneChar 0x1E Password 0x1F Telephone Number 0x20 Telephone CountryCode 0x21 Telephone AreaCode 0x22 Telephone LocalNumber 0x23 Time 0x24 Time Hour 0x25 Time MinorSec 0x26 Number FullWidth 0x27 Alphanumeric HalfWidth 0x28 Alphanumeric FullWidth 0x29 Currency Chinese 0x2A Bopomofo 0x2B Hiragana 0x2C Katakana HalfWidth 0x2D Katakana FullWidth 0x2E Hanja 0x2F Hangul HalfWidth 0x30 Hangul FullWidth 0x31 Search 0x32 Search TitleText 0x33 Search Incremental 0x34 Chinese HalfWidth 0x35 Chinese FullWidth 0x36 NativeScript 0x37","title":"Text Input Scope"},{"location":"message/#text-option-flags","text":"Flag Bits Mask Default 0000 0000 0000 0000 0x00 Accepts Return 0000 0000 0000 0001 0x01 Password 0000 0000 0000 0010 0x02 Multi Line 0000 0000 0000 0100 0x04 Spell Check Enabled 0000 0000 0000 1000 0x08 Prediction Enabled 0000 0000 0001 0000 0x10 RTL 0000 0000 0010 0000 0x20 Dismiss 0100 0000 0000 0000 0x4000","title":"Text Option Flags"},{"location":"nano/","text":"Nano Protocol Nano (aka. Nano RDP / Codename: Arcadia) is the protocol Gamestreaming is based on. You can see strong similarities when looking at the Windows IoT RDP server implementation, NanoRDPServer.exe . It's basically RTP over TCP (configuration / status of session) and UDP (data). Nano Protocol How it works TCP vs. UDP Data layout TCP Socket Padding Example RTP Header Channels Payload Types Streamer Protocol Version Channel Opening Streamer Handshaking Packets Packet Layout Control Handshake Packet Channel Control Packet Channel Control Header Channel Control Types Channel Control Payloads Create Open Close UDP Handshake Packet Streamer Packet Streamer Flags Streamer Header Audio Video Streamer Payload Type Input Payload Type Streamer Payloads Reference Timestamp Timestamp of Data Packets Frame Id Audio Audio Format Audio Codec Audio Server Handshake Audio Client Handshake Audio Control Audio Control Flags Audio Data Video Lost frame reporting Video Format Video Codec Video Server Handshake Video Client Handshake Video Control Video Control Flags Video Data Video Data Flags Input Input Button Model Input Analog Model Input Extension Model Input Server Handshake Input Client Handshake Frame Ack Input Frame Control Protocol Control Header Control Payload Type Session Init Session Create Session Create Response Session Destroy Video Statistics Realtime Telemetry Telemetry Field Change Video Quality Initiate Network Test Network Information Network Test Response Controller Event Controller Event Type How it works Client opens Broadcast Channel in SmartGlass Protocol and requests start of gamestreaming to initialize and receive the connection-data TCP Port , UDP Port and Session ID . Client creates sockets for TCP and UDP . Client sends Control Handshake Packet with own, randomly generated, Connection Id . Host responds with Control Handshake Packet and it's own Connection Id. Client starts a background loop, sending UDP Handshake packets. Host sends Channel Create and Channel Open packets Client replies with Channel Open packets for the appropriate channels Host sends Server Handshake packets for Video and Audio , announcing it's available formats Client replies with Client Handshake packets, choosing the desired format. Client sends Audio / Video Control packets, starting the stream. UDP Data comes flying in. Client stops UDP Handshake loop. ... Client processes data ... TCP vs. UDP Nano uses these two IP protocols in the following ways: TCP Control Handshaking Creating/Opening/Closing Channels Streamer Client/Server Handshaking Streamer control messaging Control Protocol messaging UDP UDP handshaking Streamer data packets Data layout The RTP header is in network / big-endian byteorder, the rest of the packet is usually in little-endian byteorder. TCP Socket All TCP packets have a nano-packet size prepended ( uint32 , Little Endian), so several packets can be sent stacked . Example of a single TCP packet with two nano packets inside: packet size #1: 0x123 nano packet #1: byte[0x123] packet size #2: 0x321 nano packet #2: byte[0x321] Ideally the chunks are split directly when received from the socket and then forwarded to the unpacker/processor/parser. Padding Nano, different to SmartGlass core, uses padding of type ANSI X.923 aka. padding with zero , the last byte defining the number of padding bytes. Aligment is 4 bytes . Example Plaintext (9 bytes) DE AD BE EF DE AD BE EF DE Padded Plaintext (12 bytes) - 3 bytes padding DE AD BE EF DE AD BE EF DE 00 00 03 RTP Header Image Source: https://de.wikipedia.org/wiki/Real-Time_Transport_Protocol Image Copyright License: CC-by-sa-3.0 Total size : 0x0C (12) V : Version (2 bits): Always 2 P : Padding (1 bit): If set, last byte of payload is padding size. X : Extension (1 bit): If set, variable size header extension exists - Not used by Nano CSRC Count : (4 bits) Should be 0 - Not used by Nano M : Marker (1 bit): Indicates a special packet in stream data Payload type : (7 bits) See Payload Types Sequence number : (16 bits) Incrementing number, indvidual to each channel, used to keep track of order and lost packets Timestamp : (32 bits) Timestamp, unsure how it's actually calculated SSRC : (32 bits) For Nano its split into 2 x 16 bits: NOTE: Only UDP packets use Connection Id field, TCP sets it to 0 Bits 0-15: Connection Id Bits 16-32: Channel Id Channels Nano communicates over the following channels + a core channel ( 0 ). Core Channel handles: Control Handshake UDP Handshake Channel Control Packet The following listed channels only process messages of type Streamer . Usage of TcpBase has not been spotted in the wild to date. Channel Id Video Microsoft::Rdp::Dct::Channel::Class::Video Audio Microsoft::Rdp::Dct::Channel::Class::Audio Chat Audio Microsoft::Rdp::Dct::Channel::Class::ChatAudio Control Microsoft::Rdp::Dct::Channel::Class::Control Input Microsoft::Rdp::Dct::Channel::Class::Input Input Feedback Microsoft::Rdp::Dct::Channel::Class::Input Feedback TCP Base Microsoft::Rdp::Dct::Channel::Class::TcpBase Payload Types Payload Type is encoded in the RTP Header Payload type field. Payload Type Value Streamer 0x23 Control 0x60 Channel Control 0x61 UDP Handshake 0x64 Streamer : Sending encoded video/audio/input data, sending Control Protocol packets Control : Initial TCP handshake, informs each participants about the used Connection Id. Channel Control : Creating / opening / closing Channels . UDP Handshake : Initial UDP handshake, used to inform the host about the used UDP port of the client side. Streamer Protocol Version Currently these are the used streamer protocol version: Video : Version 5 Audio : Version 4 Input : Version 3 Channel Opening By default, console creates and opens Channels for: Audio Video ChatAudio Control Client needs to respond with a Channel Open packet. After that, handshaking needs to be done, see Streamer Handshaking NOTE: Input and Input Feedback are somewhat special, see Input Streamer Handshaking Normally, a Server Handshake is sent by the console, client has to respond with a Client Handshake . NOTE: Input Feedback and Chat Audio are special! Packets Packet Layout \u251c\u2500\u2500 RtpHeader \u2514\u2500\u2500 Payload (RtpHeader.PayloadType) \u251c\u2500\u2500 Control Handshake \u251c\u2500\u2500 Channel Control \u2502 \u251c\u2500\u2500 Channel Create \u2502 \u251c\u2500\u2500 Channel Open \u2502 \u2514\u2500\u2500 Channel Close \u251c\u2500\u2500 UDP Handshake \u2514\u2500\u2500 Streamer \u251c\u2500\u2500 TCP Header \u251c\u2500\u2500 UDP Header \u251c\u2500\u2500 Audio Payload \u2502 \u251c\u2500\u2500 Server Handshake \u2502 \u251c\u2500\u2500 Client Handshake \u2502 \u251c\u2500\u2500 Control \u2502 \u2514\u2500\u2500 Data \u251c\u2500\u2500 Video Payload \u2502 \u251c\u2500\u2500 Server Handshake \u2502 \u251c\u2500\u2500 Client Handshake \u2502 \u251c\u2500\u2500 Control \u2502 \u2514\u2500\u2500 Data \u251c\u2500\u2500 Input Payload \u2502 \u251c\u2500\u2500 Server Handshake \u2502 \u251c\u2500\u2500 Client Handshake \u2502 \u251c\u2500\u2500 Frame Ack \u2502 \u2514\u2500\u2500 Frame \u2514\u2500\u2500 Control Payload \u2514\u2500\u2500 Control Header \u251c\u2500\u2500 Session Init \u251c\u2500\u2500 Session Create \u251c\u2500\u2500 Session Create Response \u251c\u2500\u2500 Session Destroy \u251c\u2500\u2500 Video Statistics \u251c\u2500\u2500 Realtime Telemetry \u251c\u2500\u2500 Change Video Quality \u251c\u2500\u2500 Initiate Network Test \u251c\u2500\u2500 Network Information \u251c\u2500\u2500 Network Test Response \u2514\u2500\u2500 Controller Event Control Handshake Packet Offset (hex) Offset (dec) Type Description 0x00 0 byte Type 0x01 1 uint16 Connection Id Total size : 0x03 (3) Type : Handshake type: SYN: 0 - Sent by client, ACK: 1 - Response from console Connection Id : Client sends randomly generated connection Id, Host responds with it's own. Channel Control Packet Channel Control Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channel Control Type 0x04 4 byte[] Payload Total size : variable Channel Control Type : See Channel Control Types Payload : Depending on Type-field Channel Control Types Channel Control Value Create 0x02 Open 0x03 Close 0x04 Channel Control Payloads Create Channel Control Type : 0x02 Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Name length 0x02 2 uchar[len] Channel Name 0x02 + len 2 + len uint32 Flags Total size : variable Channel Name : See Channels Flags : Unknown Open Channel Control Type : 0x03 Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags length 0x04 4 byte[len] Flags Total size : variable Flags (optional) : Depending on prepended size. Are sent by the client as-is in the responding Channel Open packet. Close Channel Control Type : 0x04 Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags Total size : 0x04 (4) Flags : Same flags as sent with Create and Open packet UDP Handshake Packet Offset (hex) Offset (dec) Type Description 0x00 0 byte Type Total size : 0x01 (1) Type : Handshake Type Streamer Packet Streamer Flags Flag Value Got Seq/Prev Seq 0x01 Unknown 0x02 Streamer Header UDP usually uses flags: 0x0 . TCP usually uses flags: 0x3 . For FEC there are additional flags to process (TODO). Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags *0x?? *?? uint32 *Sequence Number *0x?? *?? uint32 *Previous Sequence Number 0x?? ?? uint32 Streamer Payload Type *0x?? *?? uint32 *Streamer Payload Length 0x?? ?? byte[*len] Streamer Payload Total size : variable Streamer Payload Length : Only used if Streamer Payload Type is not 0 (0: Control packet with own header) Flags : Depending on used Channel Sequence Number : If Flag Got Seq/Prev Seq is set -> incrementing number, specific for channel and participant side Previous Sequence Number : If Flag Got Seq/Prev Seq is set -> previously sent Sequence Number Streamer Payload Type : See Audio / Video Payload Type and Input Payload Type Streamer Payload : Depending on Streamer Payload Type Audio Video Streamer Payload Type Type Value Server Handshake 0x01 Client Handshake 0x02 Control 0x03 Data 0x04 Input Payload Type Type Value Server Handshake 0x01 Client Handshake 0x02 Frame Ack 0x03 Frame 0x04 Streamer Payloads Reference Timestamp Reference Timestamp is milliseconds since epoch. Timestamp of Data Packets The Timestamp used on each Data/Frame Packet is current time in microseconds -> relative to the Reference Timestamp Frame Id The initial Frame Id is chosen randomly by the participant that's sending the handshake. Frame Ids of the data/frame packet will start with the initial value and increment on each packet. Audio NOTE: For ChatAudio Channel , the client needs to send the Audio Server Handshake to the console after opening the channel!!! Console responds with Audio Client Handshake Audio Format Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channels 0x04 4 uint32 Sample Rate 0x08 8 uint32 Audio Codec If AudioCodec is PCM: 0x0C 12 uint32 Bit Depth 0x10 16 uint32 Type Total size : variable Channels : Audio Channels of encoded data Sample Rate : Samplerate of encoded data Audio Codec : See Audio Codec Bit Depth (optional) : If Audio Codec is PCM this field gives the bit depth of encoded data Type (optional) : If Audio Codec is PCM this field gives the type ( Integer or Float ) of encoded data Audio Codec Codec Value Opus 0x00 AAC 0x01 PCM 0x02 Audio Server Handshake Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Protocol Version 0x04 4 uint64 Reference Timestamp 0x0C 12 uint32 Formats length 0x10 16 AudioFormat[len] Audio Formats Total size : variable Protocol Version : See Streamer Protocol Version Reference Timestamp : See Reference Timestamp Audio Formats : Available Audio Formats , Array of Audio Format Audio Client Handshake Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Initial Frame Id 0x04 4 AudioFormat Audio Format Total size : variable Initial Frame Id : See Frame Id Audio Format : By client desired Audio Format Audio Control Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Audio Control Flags Total size : 0x04 (4) Audio Control Flags : See Audio Control Flags Audio Control Flags Flag Bits Mask Reinitialize 0000 0000 0000 0010 0x02 Start Stream 0000 0000 0000 1000 0x08 Stop Stream 0000 0000 0001 0000 0x10 Audio Data Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags 0x04 4 uint32 Frame Id 0x08 8 uint64 Timestamp 0x10 16 uint32 Data length 0x14 20 byte[len] Data Total size : variable Flags : Unknown, for AAC it seems to always be 0x4 Frame Id : See Frame Id Timestamp : See Timestamp of Data Packets Data : Encoded data Video Lost frame reporting TODO Video Format Offset (hex) Offset (dec) Type Description 0x00 0 uint32 FPS 0x04 4 uint32 Width 0x08 8 uint32 Height 0x0C 12 uint32 Video Codec If VideoCodec is RGB: 0x10 16 uint32 Bpp 0x14 20 uint32 Bytes 0x18 24 uint64 Red Mask 0x20 32 uint64 Green Mask 0x28 40 uint64 Blue Mask Total size : variable FPS : Frames per second Width : Video Frame Width Height : Video Frame Height Video Codec : See Video Codec Bpp (optional) : If Video Codec is RGB this field gives the bits per pixel (color depth) Bytes (optional) : If Video Codec is RGB this field gives the bytes per pixel Red Mask (optional) : If Video Codec is RGB this field gives the Red Mask Green Mask (optional) : If Video Codec is RGB this field gives the Green Mask Blue Mask (optional) : If Video Codec is RGB this field gives the Blue Mask Video Codec Codec Value H264 0x00 YUV 0x01 RGB 0x02 Video Server Handshake Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Protocol Version 0x04 4 uint32 Width 0x08 8 uint32 Height 0x0C 12 uint32 FPS 0x10 16 uint64 Reference Timestamp 0x18 24 uint32 Formats length 0x1C 28 VideoFormat[len] Video Formats Total size : variable Protocol Version : See Streamer Protocol Version Width : Video Width Height : Video Height FPS : Frames per second Reference Timestamp : Reference Timestamp Video Formats : Available Video Formats , Array of Video Format Video Client Handshake Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Initial Frame Id 0x04 4 VideoFormat Video Format Total size : variable Initial Frame Id : See Frame Id Video Format : By client desired Video Format Video Control Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Video Control Flags If \"Last displayed frame\" set: 0x?? ? uint32 Last displayed Frame Id 0x?? ? uint64 Timestamp If \"Queue Depth\" set: 0x?? ? uint32 Queue Depth If \"Lost frames\" set: 0x?? ? uint32 First lost Frame 0x?? ? uint32 Last lost Frame Total size : variable Video Control Flags : See Video Control Flags Last displayed Frame Id (optional) : If flag Last displayed frame is set, this informs the host about the last displayed Video Frame by Frame Id Timestamp (optional) : If flag Last displayed frame is set, this informs the host about the time the frame was displayed ( Timestamp of Data Packets ) Queue Depth (optional) : If flag Queue Depth is set: Informs the host about queue depth First lost Frame (optional) : If flag Lost frames is set, this informs the host about the first last Frame, given the Frame Id Last lost Frame (optional) : If flag Lost frames is set, this informs the host about the last last Frame, given the Frame Id Video Control Flags Flag Bits Mask Request Keyframe 0000 0000 0000 0100 0x04 Start Stream 0000 0000 0000 1000 0x08 Stop Stream 0000 0000 0001 0000 0x10 Queue Depth 0000 0000 0010 0000 0x20 Lost frames 0000 0000 0100 0000 0x40 Last displayed frame 0000 0000 1000 0000 0x80 Video Data Header: Streamer Header Assembling video frames: Frames are sequential by Frame Id Each Frame aka. Frame Id has several chunks Chunk size is provided in Data length , Position of Data chunk in Frame is provided with Offset Packet count gives the amount of chunks in a frame To assemble the full frame do the following: Collect all packets for a specific Frame Id Check if Packet count equals to collected packets/chunks Sort the chunks by Offset Concatenate the chunks Data section The resulting final Frame blob should equal in size to Total size Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags 0x04 4 uint32 Frame Id 0x08 8 uint64 Timestamp 0x10 16 uint32 Total size 0x14 20 uint32 Packet count 0x18 24 uint32 Offset 0x1C 28 uint32 Data length 0x20 32 byte[len] Data Total size : variable Flags : See Video Data Flags Frame Id : See Frame Id Timestamp : See Timestamp of Data Packets Total size : Total size of the Video Frame Packet count : Count of total frame chunks Offset : Beginning position of current frame chunk Data : Encoded data Video Data Flags Flag Bits Mask Keyframe 0000 0000 0000 0010 0x02 Input NOTE: Input channel does not get created by default! You need to send a Controller Event over Control Protocol to make the console Create the Input Channel . After client sends the Open Input Channel packet to the console, console sends an Open Input Channel packet packet too - then console creates and opens the Input Feedback Channel . Client opens Input Feedback Channel . Client sends the Input Server Handshake for Input Feedback - console responds with Input Client Handshake . Console will further send a Input Server Handshake for Input which client needs to respond with Input Client Handshake Input Button Model This structure starts with all-zero . When a button-state is changed, the appropriate field is incremented by one. Advice : Keep track of the button-state, don't increment the value if new button- state is the same as the old one - otherwise you will provoke a stuck button in case an Input Frame packet is lost. Example // Initial value - button is not pressed button_state.A = state.RELEASED button_model.A = 0 SendPacket() while (getting_input_data) { // A button is pressed if (new_state != button_state.A) { button_model.A++ button_state.A = new_state SendPacket() } } // State can be checked from value like: // bool released = (button_model.A % 2) == 0 || button_model.A == 0 Offset (hex) Offset (dec) Type Description 0x00 0 byte D-Pad Up 0x01 1 byte D-Pad Down 0x02 2 byte D-Pad Left 0x03 3 byte D-Pad Right 0x04 4 byte Start 0x05 5 byte Back 0x06 6 byte Left thumbstick 0x07 7 byte Right thumbstick 0x08 8 byte Left shoulder 0x09 9 byte Right shoulder 0x0A 10 byte Guide 0x0B 11 byte Unknown 0x0C 12 byte A 0x0D 13 byte B 0x0E 14 byte X 0x0F 15 byte Y Total size : 0x10 (16) Input Analog Model Offset (hex) Offset (dec) Type Description 0x00 0 byte Left Trigger 0x01 1 byte Right Trigger 0x02 2 uint16 Left thumbstick X 0x04 4 uint16 Left thumbstick Y 0x06 6 uint16 Right thumbstick X 0x08 8 uint16 Right thumbstick Y 0x0A 10 byte Left Rumble trigger 0x0B 11 byte Right Rumble trigger 0x0C 12 byte Left Rumble handle 0x0D 13 byte Right Rumble handle Total size : 0x0E (14) Input Extension Model Offset (hex) Offset (dec) Type Description 0x00 0 byte Unknown 1 0x01 1 byte Unknown 2 0x02 2 byte Left Rumble trigger 2 0x03 3 byte Right Rumble trigger 2 0x04 4 byte Left Rumble handle 2 0x05 5 byte Right Rumble handle 2 0x06 6 byte Unknown 3 0x07 7 byte Unknown 4 0x08 8 byte Unknown 5 Total size : 0x09 (9) Unknown 1 : Set to 1 for gamepad Input Server Handshake Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Protocol Version 0x04 4 uint32 Desktop Width 0x08 8 uint32 Desktop Height 0x0C 12 uint32 Max Touches 0x10 16 uint32 Initial frame Id Total size : 0x14 (20) Protocol Version : See Streamer Protocol Version Desktop Width : Host's display width Desktop Height : Host's display height Max Touches : 0 Initial Frame Id : Frame Id Input Client Handshake Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Max Touches 0x04 4 uint64 Reference Timestamp Total size : 0x0C (12) Max Touches : Input: 10 , Input Feedback: 0 Reference Timestamp : See Reference Timestamp Frame Ack Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Acked frame Total size : 0x04 (4) Acked frame : Frame Id of Input Frame to acknowledge Input Frame Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Frame Id 0x04 4 uint64 Timestamp 0x0C 12 uint64 Created Timestamp 0x14 20 byte[16] Input Button Model 0x24 36 byte[14] Input Analog Model If remaining data: 0x32 50 byte[9] Input Extension Model Total size : 0x32 (50) or 0x3B (59) Frame Id : See Frame Id Timestamp : See Timestamp of Data Packets Created Timestamp : See Timestamp of Data Packets Input Button Model : See Input Button Model Input Analog Model : See Input Analog Model Input Extension Model (optional) : Input Extension Model Control Protocol Header: Streamer Header Control Protocol packets have Streamer Payload Type set to 0 Control Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Previous Sequence (DUPE) 0x04 4 uint16 Unknown 1 0x06 6 uint16 Unknown 2 0x08 8 uint16 Control Payload Type 0x0A 10 byte[] Control Payload Total size : variable Previous Sequence : Previous Sequence Number (DUPE) Unknown 1 : TODO: 1 Unknown 2 : TODO: 1406 Control Payload Type : See Control Payload Type Control Payload : Depends on Control Payload Type Control Payload Type Type Value Session Init 0x01 Session Create 0x02 Session Create Response 0x03 Session Destroy 0x04 Video Statistics 0x05 Realtime Telemetry 0x06 Change Video Quality 0x07 Initiate Network Test 0x08 Network Information 0x09 Network Test Response 0x0A Controller Event 0x0B Session Init Offset (hex) Offset (dec) Type Description 0x00 0 byte[] Unknown Session Create Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Length 0x04 4 byte[length] Unknown Session Create Response Offset (hex) Offset (dec) Type Description 0x00 0 byte[] Unknown Session Destroy Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Length 0x08 8 uint32 Unknown 2 Video Statistics Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Unknown 2 0x08 8 uint32 Unknown 3 0x0C 12 uint32 Unknown 4 0x10 16 uint32 Unknown 5 0x14 20 uint32 Unknown 6 Realtime Telemetry Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Field count 0x02 2 TelemetryField[count] Telemetry Fields Telemetry Field Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Key 0x02 2 uint64 Value Change Video Quality Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Unknown 2 0x08 8 uint32 Unknown 3 0x0C 12 uint32 Unknown 4 0x10 16 uint32 Unknown 5 0x14 20 uint32 Unknown 6 Initiate Network Test Offset (hex) Offset (dec) Type Description 0x00 0 byte[] Unknown Network Information Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Unknown 1 0x08 8 byte Unknown 2 0x09 9 uint32 Unknown 3 Network Test Response Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Unknown 2 0x08 8 uint32 Unknown 3 0x0C 12 uint32 Unknown 4 0x10 16 uint32 Unknown 5 0x14 20 uint64 Unknown 6 0x1C 28 uint64 Unknown 7 0x24 36 uint32 Unknown 8 Controller Event By sending a Controller Event packet to the console, the console will open the Input / Input Feedback channels and send the appropriate Channel Open packets to the client. Offset (hex) Offset (dec) Type Description 0x00 0 byte Event 0x01 1 byte Controller Number Event : Controller Event Type Controller Number : Null-indexed controller number Controller Event Type Event Value Removed 0x00 Added 0x01","title":"Gamestream (Nano)"},{"location":"nano/#nano-protocol","text":"Nano (aka. Nano RDP / Codename: Arcadia) is the protocol Gamestreaming is based on. You can see strong similarities when looking at the Windows IoT RDP server implementation, NanoRDPServer.exe . It's basically RTP over TCP (configuration / status of session) and UDP (data). Nano Protocol How it works TCP vs. UDP Data layout TCP Socket Padding Example RTP Header Channels Payload Types Streamer Protocol Version Channel Opening Streamer Handshaking Packets Packet Layout Control Handshake Packet Channel Control Packet Channel Control Header Channel Control Types Channel Control Payloads Create Open Close UDP Handshake Packet Streamer Packet Streamer Flags Streamer Header Audio Video Streamer Payload Type Input Payload Type Streamer Payloads Reference Timestamp Timestamp of Data Packets Frame Id Audio Audio Format Audio Codec Audio Server Handshake Audio Client Handshake Audio Control Audio Control Flags Audio Data Video Lost frame reporting Video Format Video Codec Video Server Handshake Video Client Handshake Video Control Video Control Flags Video Data Video Data Flags Input Input Button Model Input Analog Model Input Extension Model Input Server Handshake Input Client Handshake Frame Ack Input Frame Control Protocol Control Header Control Payload Type Session Init Session Create Session Create Response Session Destroy Video Statistics Realtime Telemetry Telemetry Field Change Video Quality Initiate Network Test Network Information Network Test Response Controller Event Controller Event Type","title":"Nano Protocol"},{"location":"nano/#how-it-works","text":"Client opens Broadcast Channel in SmartGlass Protocol and requests start of gamestreaming to initialize and receive the connection-data TCP Port , UDP Port and Session ID . Client creates sockets for TCP and UDP . Client sends Control Handshake Packet with own, randomly generated, Connection Id . Host responds with Control Handshake Packet and it's own Connection Id. Client starts a background loop, sending UDP Handshake packets. Host sends Channel Create and Channel Open packets Client replies with Channel Open packets for the appropriate channels Host sends Server Handshake packets for Video and Audio , announcing it's available formats Client replies with Client Handshake packets, choosing the desired format. Client sends Audio / Video Control packets, starting the stream. UDP Data comes flying in. Client stops UDP Handshake loop. ... Client processes data ...","title":"How it works"},{"location":"nano/#tcp-vs-udp","text":"Nano uses these two IP protocols in the following ways: TCP Control Handshaking Creating/Opening/Closing Channels Streamer Client/Server Handshaking Streamer control messaging Control Protocol messaging UDP UDP handshaking Streamer data packets","title":"TCP vs. UDP"},{"location":"nano/#data-layout","text":"The RTP header is in network / big-endian byteorder, the rest of the packet is usually in little-endian byteorder.","title":"Data layout"},{"location":"nano/#tcp-socket","text":"All TCP packets have a nano-packet size prepended ( uint32 , Little Endian), so several packets can be sent stacked . Example of a single TCP packet with two nano packets inside: packet size #1: 0x123 nano packet #1: byte[0x123] packet size #2: 0x321 nano packet #2: byte[0x321] Ideally the chunks are split directly when received from the socket and then forwarded to the unpacker/processor/parser.","title":"TCP Socket"},{"location":"nano/#padding","text":"Nano, different to SmartGlass core, uses padding of type ANSI X.923 aka. padding with zero , the last byte defining the number of padding bytes. Aligment is 4 bytes .","title":"Padding"},{"location":"nano/#example","text":"Plaintext (9 bytes) DE AD BE EF DE AD BE EF DE Padded Plaintext (12 bytes) - 3 bytes padding DE AD BE EF DE AD BE EF DE 00 00 03","title":"Example"},{"location":"nano/#rtp-header","text":"Image Source: https://de.wikipedia.org/wiki/Real-Time_Transport_Protocol Image Copyright License: CC-by-sa-3.0 Total size : 0x0C (12) V : Version (2 bits): Always 2 P : Padding (1 bit): If set, last byte of payload is padding size. X : Extension (1 bit): If set, variable size header extension exists - Not used by Nano CSRC Count : (4 bits) Should be 0 - Not used by Nano M : Marker (1 bit): Indicates a special packet in stream data Payload type : (7 bits) See Payload Types Sequence number : (16 bits) Incrementing number, indvidual to each channel, used to keep track of order and lost packets Timestamp : (32 bits) Timestamp, unsure how it's actually calculated SSRC : (32 bits) For Nano its split into 2 x 16 bits: NOTE: Only UDP packets use Connection Id field, TCP sets it to 0 Bits 0-15: Connection Id Bits 16-32: Channel Id","title":"RTP Header"},{"location":"nano/#channels","text":"Nano communicates over the following channels + a core channel ( 0 ). Core Channel handles: Control Handshake UDP Handshake Channel Control Packet The following listed channels only process messages of type Streamer . Usage of TcpBase has not been spotted in the wild to date. Channel Id Video Microsoft::Rdp::Dct::Channel::Class::Video Audio Microsoft::Rdp::Dct::Channel::Class::Audio Chat Audio Microsoft::Rdp::Dct::Channel::Class::ChatAudio Control Microsoft::Rdp::Dct::Channel::Class::Control Input Microsoft::Rdp::Dct::Channel::Class::Input Input Feedback Microsoft::Rdp::Dct::Channel::Class::Input Feedback TCP Base Microsoft::Rdp::Dct::Channel::Class::TcpBase","title":"Channels"},{"location":"nano/#payload-types","text":"Payload Type is encoded in the RTP Header Payload type field. Payload Type Value Streamer 0x23 Control 0x60 Channel Control 0x61 UDP Handshake 0x64 Streamer : Sending encoded video/audio/input data, sending Control Protocol packets Control : Initial TCP handshake, informs each participants about the used Connection Id. Channel Control : Creating / opening / closing Channels . UDP Handshake : Initial UDP handshake, used to inform the host about the used UDP port of the client side.","title":"Payload Types"},{"location":"nano/#streamer-protocol-version","text":"Currently these are the used streamer protocol version: Video : Version 5 Audio : Version 4 Input : Version 3","title":"Streamer Protocol Version"},{"location":"nano/#channel-opening","text":"By default, console creates and opens Channels for: Audio Video ChatAudio Control Client needs to respond with a Channel Open packet. After that, handshaking needs to be done, see Streamer Handshaking NOTE: Input and Input Feedback are somewhat special, see Input","title":"Channel Opening"},{"location":"nano/#streamer-handshaking","text":"Normally, a Server Handshake is sent by the console, client has to respond with a Client Handshake . NOTE: Input Feedback and Chat Audio are special!","title":"Streamer Handshaking"},{"location":"nano/#packets","text":"","title":"Packets"},{"location":"nano/#packet-layout","text":"\u251c\u2500\u2500 RtpHeader \u2514\u2500\u2500 Payload (RtpHeader.PayloadType) \u251c\u2500\u2500 Control Handshake \u251c\u2500\u2500 Channel Control \u2502 \u251c\u2500\u2500 Channel Create \u2502 \u251c\u2500\u2500 Channel Open \u2502 \u2514\u2500\u2500 Channel Close \u251c\u2500\u2500 UDP Handshake \u2514\u2500\u2500 Streamer \u251c\u2500\u2500 TCP Header \u251c\u2500\u2500 UDP Header \u251c\u2500\u2500 Audio Payload \u2502 \u251c\u2500\u2500 Server Handshake \u2502 \u251c\u2500\u2500 Client Handshake \u2502 \u251c\u2500\u2500 Control \u2502 \u2514\u2500\u2500 Data \u251c\u2500\u2500 Video Payload \u2502 \u251c\u2500\u2500 Server Handshake \u2502 \u251c\u2500\u2500 Client Handshake \u2502 \u251c\u2500\u2500 Control \u2502 \u2514\u2500\u2500 Data \u251c\u2500\u2500 Input Payload \u2502 \u251c\u2500\u2500 Server Handshake \u2502 \u251c\u2500\u2500 Client Handshake \u2502 \u251c\u2500\u2500 Frame Ack \u2502 \u2514\u2500\u2500 Frame \u2514\u2500\u2500 Control Payload \u2514\u2500\u2500 Control Header \u251c\u2500\u2500 Session Init \u251c\u2500\u2500 Session Create \u251c\u2500\u2500 Session Create Response \u251c\u2500\u2500 Session Destroy \u251c\u2500\u2500 Video Statistics \u251c\u2500\u2500 Realtime Telemetry \u251c\u2500\u2500 Change Video Quality \u251c\u2500\u2500 Initiate Network Test \u251c\u2500\u2500 Network Information \u251c\u2500\u2500 Network Test Response \u2514\u2500\u2500 Controller Event","title":"Packet Layout"},{"location":"nano/#control-handshake-packet","text":"Offset (hex) Offset (dec) Type Description 0x00 0 byte Type 0x01 1 uint16 Connection Id Total size : 0x03 (3) Type : Handshake type: SYN: 0 - Sent by client, ACK: 1 - Response from console Connection Id : Client sends randomly generated connection Id, Host responds with it's own.","title":"Control Handshake Packet"},{"location":"nano/#channel-control-packet","text":"","title":"Channel Control Packet"},{"location":"nano/#channel-control-header","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channel Control Type 0x04 4 byte[] Payload Total size : variable Channel Control Type : See Channel Control Types Payload : Depending on Type-field","title":"Channel Control Header"},{"location":"nano/#channel-control-types","text":"Channel Control Value Create 0x02 Open 0x03 Close 0x04","title":"Channel Control Types"},{"location":"nano/#channel-control-payloads","text":"","title":"Channel Control Payloads"},{"location":"nano/#create","text":"Channel Control Type : 0x02 Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Name length 0x02 2 uchar[len] Channel Name 0x02 + len 2 + len uint32 Flags Total size : variable Channel Name : See Channels Flags : Unknown","title":"Create"},{"location":"nano/#open","text":"Channel Control Type : 0x03 Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags length 0x04 4 byte[len] Flags Total size : variable Flags (optional) : Depending on prepended size. Are sent by the client as-is in the responding Channel Open packet.","title":"Open"},{"location":"nano/#close","text":"Channel Control Type : 0x04 Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags Total size : 0x04 (4) Flags : Same flags as sent with Create and Open packet","title":"Close"},{"location":"nano/#udp-handshake-packet","text":"Offset (hex) Offset (dec) Type Description 0x00 0 byte Type Total size : 0x01 (1) Type : Handshake Type","title":"UDP Handshake Packet"},{"location":"nano/#streamer-packet","text":"","title":"Streamer Packet"},{"location":"nano/#streamer-flags","text":"Flag Value Got Seq/Prev Seq 0x01 Unknown 0x02","title":"Streamer Flags"},{"location":"nano/#streamer-header","text":"UDP usually uses flags: 0x0 . TCP usually uses flags: 0x3 . For FEC there are additional flags to process (TODO). Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags *0x?? *?? uint32 *Sequence Number *0x?? *?? uint32 *Previous Sequence Number 0x?? ?? uint32 Streamer Payload Type *0x?? *?? uint32 *Streamer Payload Length 0x?? ?? byte[*len] Streamer Payload Total size : variable Streamer Payload Length : Only used if Streamer Payload Type is not 0 (0: Control packet with own header) Flags : Depending on used Channel Sequence Number : If Flag Got Seq/Prev Seq is set -> incrementing number, specific for channel and participant side Previous Sequence Number : If Flag Got Seq/Prev Seq is set -> previously sent Sequence Number Streamer Payload Type : See Audio / Video Payload Type and Input Payload Type Streamer Payload : Depending on Streamer Payload Type","title":"Streamer Header"},{"location":"nano/#audio-video-streamer-payload-type","text":"Type Value Server Handshake 0x01 Client Handshake 0x02 Control 0x03 Data 0x04","title":"Audio Video Streamer Payload Type"},{"location":"nano/#input-payload-type","text":"Type Value Server Handshake 0x01 Client Handshake 0x02 Frame Ack 0x03 Frame 0x04","title":"Input Payload Type"},{"location":"nano/#streamer-payloads","text":"","title":"Streamer Payloads"},{"location":"nano/#reference-timestamp","text":"Reference Timestamp is milliseconds since epoch.","title":"Reference Timestamp"},{"location":"nano/#timestamp-of-data-packets","text":"The Timestamp used on each Data/Frame Packet is current time in microseconds -> relative to the Reference Timestamp","title":"Timestamp of Data Packets"},{"location":"nano/#frame-id","text":"The initial Frame Id is chosen randomly by the participant that's sending the handshake. Frame Ids of the data/frame packet will start with the initial value and increment on each packet.","title":"Frame Id"},{"location":"nano/#audio","text":"NOTE: For ChatAudio Channel , the client needs to send the Audio Server Handshake to the console after opening the channel!!! Console responds with Audio Client Handshake","title":"Audio"},{"location":"nano/#audio-format","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Channels 0x04 4 uint32 Sample Rate 0x08 8 uint32 Audio Codec If AudioCodec is PCM: 0x0C 12 uint32 Bit Depth 0x10 16 uint32 Type Total size : variable Channels : Audio Channels of encoded data Sample Rate : Samplerate of encoded data Audio Codec : See Audio Codec Bit Depth (optional) : If Audio Codec is PCM this field gives the bit depth of encoded data Type (optional) : If Audio Codec is PCM this field gives the type ( Integer or Float ) of encoded data","title":"Audio Format"},{"location":"nano/#audio-codec","text":"Codec Value Opus 0x00 AAC 0x01 PCM 0x02","title":"Audio Codec"},{"location":"nano/#audio-server-handshake","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Protocol Version 0x04 4 uint64 Reference Timestamp 0x0C 12 uint32 Formats length 0x10 16 AudioFormat[len] Audio Formats Total size : variable Protocol Version : See Streamer Protocol Version Reference Timestamp : See Reference Timestamp Audio Formats : Available Audio Formats , Array of Audio Format","title":"Audio Server Handshake"},{"location":"nano/#audio-client-handshake","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Initial Frame Id 0x04 4 AudioFormat Audio Format Total size : variable Initial Frame Id : See Frame Id Audio Format : By client desired Audio Format","title":"Audio Client Handshake"},{"location":"nano/#audio-control","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Audio Control Flags Total size : 0x04 (4) Audio Control Flags : See Audio Control Flags","title":"Audio Control"},{"location":"nano/#audio-control-flags","text":"Flag Bits Mask Reinitialize 0000 0000 0000 0010 0x02 Start Stream 0000 0000 0000 1000 0x08 Stop Stream 0000 0000 0001 0000 0x10","title":"Audio Control Flags"},{"location":"nano/#audio-data","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags 0x04 4 uint32 Frame Id 0x08 8 uint64 Timestamp 0x10 16 uint32 Data length 0x14 20 byte[len] Data Total size : variable Flags : Unknown, for AAC it seems to always be 0x4 Frame Id : See Frame Id Timestamp : See Timestamp of Data Packets Data : Encoded data","title":"Audio Data"},{"location":"nano/#video","text":"","title":"Video"},{"location":"nano/#lost-frame-reporting","text":"TODO","title":"Lost frame reporting"},{"location":"nano/#video-format","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 FPS 0x04 4 uint32 Width 0x08 8 uint32 Height 0x0C 12 uint32 Video Codec If VideoCodec is RGB: 0x10 16 uint32 Bpp 0x14 20 uint32 Bytes 0x18 24 uint64 Red Mask 0x20 32 uint64 Green Mask 0x28 40 uint64 Blue Mask Total size : variable FPS : Frames per second Width : Video Frame Width Height : Video Frame Height Video Codec : See Video Codec Bpp (optional) : If Video Codec is RGB this field gives the bits per pixel (color depth) Bytes (optional) : If Video Codec is RGB this field gives the bytes per pixel Red Mask (optional) : If Video Codec is RGB this field gives the Red Mask Green Mask (optional) : If Video Codec is RGB this field gives the Green Mask Blue Mask (optional) : If Video Codec is RGB this field gives the Blue Mask","title":"Video Format"},{"location":"nano/#video-codec","text":"Codec Value H264 0x00 YUV 0x01 RGB 0x02","title":"Video Codec"},{"location":"nano/#video-server-handshake","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Protocol Version 0x04 4 uint32 Width 0x08 8 uint32 Height 0x0C 12 uint32 FPS 0x10 16 uint64 Reference Timestamp 0x18 24 uint32 Formats length 0x1C 28 VideoFormat[len] Video Formats Total size : variable Protocol Version : See Streamer Protocol Version Width : Video Width Height : Video Height FPS : Frames per second Reference Timestamp : Reference Timestamp Video Formats : Available Video Formats , Array of Video Format","title":"Video Server Handshake"},{"location":"nano/#video-client-handshake","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Initial Frame Id 0x04 4 VideoFormat Video Format Total size : variable Initial Frame Id : See Frame Id Video Format : By client desired Video Format","title":"Video Client Handshake"},{"location":"nano/#video-control","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Video Control Flags If \"Last displayed frame\" set: 0x?? ? uint32 Last displayed Frame Id 0x?? ? uint64 Timestamp If \"Queue Depth\" set: 0x?? ? uint32 Queue Depth If \"Lost frames\" set: 0x?? ? uint32 First lost Frame 0x?? ? uint32 Last lost Frame Total size : variable Video Control Flags : See Video Control Flags Last displayed Frame Id (optional) : If flag Last displayed frame is set, this informs the host about the last displayed Video Frame by Frame Id Timestamp (optional) : If flag Last displayed frame is set, this informs the host about the time the frame was displayed ( Timestamp of Data Packets ) Queue Depth (optional) : If flag Queue Depth is set: Informs the host about queue depth First lost Frame (optional) : If flag Lost frames is set, this informs the host about the first last Frame, given the Frame Id Last lost Frame (optional) : If flag Lost frames is set, this informs the host about the last last Frame, given the Frame Id","title":"Video Control"},{"location":"nano/#video-control-flags","text":"Flag Bits Mask Request Keyframe 0000 0000 0000 0100 0x04 Start Stream 0000 0000 0000 1000 0x08 Stop Stream 0000 0000 0001 0000 0x10 Queue Depth 0000 0000 0010 0000 0x20 Lost frames 0000 0000 0100 0000 0x40 Last displayed frame 0000 0000 1000 0000 0x80","title":"Video Control Flags"},{"location":"nano/#video-data","text":"Header: Streamer Header Assembling video frames: Frames are sequential by Frame Id Each Frame aka. Frame Id has several chunks Chunk size is provided in Data length , Position of Data chunk in Frame is provided with Offset Packet count gives the amount of chunks in a frame To assemble the full frame do the following: Collect all packets for a specific Frame Id Check if Packet count equals to collected packets/chunks Sort the chunks by Offset Concatenate the chunks Data section The resulting final Frame blob should equal in size to Total size Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags 0x04 4 uint32 Frame Id 0x08 8 uint64 Timestamp 0x10 16 uint32 Total size 0x14 20 uint32 Packet count 0x18 24 uint32 Offset 0x1C 28 uint32 Data length 0x20 32 byte[len] Data Total size : variable Flags : See Video Data Flags Frame Id : See Frame Id Timestamp : See Timestamp of Data Packets Total size : Total size of the Video Frame Packet count : Count of total frame chunks Offset : Beginning position of current frame chunk Data : Encoded data","title":"Video Data"},{"location":"nano/#video-data-flags","text":"Flag Bits Mask Keyframe 0000 0000 0000 0010 0x02","title":"Video Data Flags"},{"location":"nano/#input","text":"NOTE: Input channel does not get created by default! You need to send a Controller Event over Control Protocol to make the console Create the Input Channel . After client sends the Open Input Channel packet to the console, console sends an Open Input Channel packet packet too - then console creates and opens the Input Feedback Channel . Client opens Input Feedback Channel . Client sends the Input Server Handshake for Input Feedback - console responds with Input Client Handshake . Console will further send a Input Server Handshake for Input which client needs to respond with Input Client Handshake","title":"Input"},{"location":"nano/#input-button-model","text":"This structure starts with all-zero . When a button-state is changed, the appropriate field is incremented by one. Advice : Keep track of the button-state, don't increment the value if new button- state is the same as the old one - otherwise you will provoke a stuck button in case an Input Frame packet is lost. Example // Initial value - button is not pressed button_state.A = state.RELEASED button_model.A = 0 SendPacket() while (getting_input_data) { // A button is pressed if (new_state != button_state.A) { button_model.A++ button_state.A = new_state SendPacket() } } // State can be checked from value like: // bool released = (button_model.A % 2) == 0 || button_model.A == 0 Offset (hex) Offset (dec) Type Description 0x00 0 byte D-Pad Up 0x01 1 byte D-Pad Down 0x02 2 byte D-Pad Left 0x03 3 byte D-Pad Right 0x04 4 byte Start 0x05 5 byte Back 0x06 6 byte Left thumbstick 0x07 7 byte Right thumbstick 0x08 8 byte Left shoulder 0x09 9 byte Right shoulder 0x0A 10 byte Guide 0x0B 11 byte Unknown 0x0C 12 byte A 0x0D 13 byte B 0x0E 14 byte X 0x0F 15 byte Y Total size : 0x10 (16)","title":"Input Button Model"},{"location":"nano/#input-analog-model","text":"Offset (hex) Offset (dec) Type Description 0x00 0 byte Left Trigger 0x01 1 byte Right Trigger 0x02 2 uint16 Left thumbstick X 0x04 4 uint16 Left thumbstick Y 0x06 6 uint16 Right thumbstick X 0x08 8 uint16 Right thumbstick Y 0x0A 10 byte Left Rumble trigger 0x0B 11 byte Right Rumble trigger 0x0C 12 byte Left Rumble handle 0x0D 13 byte Right Rumble handle Total size : 0x0E (14)","title":"Input Analog Model"},{"location":"nano/#input-extension-model","text":"Offset (hex) Offset (dec) Type Description 0x00 0 byte Unknown 1 0x01 1 byte Unknown 2 0x02 2 byte Left Rumble trigger 2 0x03 3 byte Right Rumble trigger 2 0x04 4 byte Left Rumble handle 2 0x05 5 byte Right Rumble handle 2 0x06 6 byte Unknown 3 0x07 7 byte Unknown 4 0x08 8 byte Unknown 5 Total size : 0x09 (9) Unknown 1 : Set to 1 for gamepad","title":"Input Extension Model"},{"location":"nano/#input-server-handshake","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Protocol Version 0x04 4 uint32 Desktop Width 0x08 8 uint32 Desktop Height 0x0C 12 uint32 Max Touches 0x10 16 uint32 Initial frame Id Total size : 0x14 (20) Protocol Version : See Streamer Protocol Version Desktop Width : Host's display width Desktop Height : Host's display height Max Touches : 0 Initial Frame Id : Frame Id","title":"Input Server Handshake"},{"location":"nano/#input-client-handshake","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Max Touches 0x04 4 uint64 Reference Timestamp Total size : 0x0C (12) Max Touches : Input: 10 , Input Feedback: 0 Reference Timestamp : See Reference Timestamp","title":"Input Client Handshake"},{"location":"nano/#frame-ack","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Acked frame Total size : 0x04 (4) Acked frame : Frame Id of Input Frame to acknowledge","title":"Frame Ack"},{"location":"nano/#input-frame","text":"Header: Streamer Header Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Frame Id 0x04 4 uint64 Timestamp 0x0C 12 uint64 Created Timestamp 0x14 20 byte[16] Input Button Model 0x24 36 byte[14] Input Analog Model If remaining data: 0x32 50 byte[9] Input Extension Model Total size : 0x32 (50) or 0x3B (59) Frame Id : See Frame Id Timestamp : See Timestamp of Data Packets Created Timestamp : See Timestamp of Data Packets Input Button Model : See Input Button Model Input Analog Model : See Input Analog Model Input Extension Model (optional) : Input Extension Model","title":"Input Frame"},{"location":"nano/#control-protocol","text":"Header: Streamer Header Control Protocol packets have Streamer Payload Type set to 0","title":"Control Protocol"},{"location":"nano/#control-header","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Previous Sequence (DUPE) 0x04 4 uint16 Unknown 1 0x06 6 uint16 Unknown 2 0x08 8 uint16 Control Payload Type 0x0A 10 byte[] Control Payload Total size : variable Previous Sequence : Previous Sequence Number (DUPE) Unknown 1 : TODO: 1 Unknown 2 : TODO: 1406 Control Payload Type : See Control Payload Type Control Payload : Depends on Control Payload Type","title":"Control Header"},{"location":"nano/#control-payload-type","text":"Type Value Session Init 0x01 Session Create 0x02 Session Create Response 0x03 Session Destroy 0x04 Video Statistics 0x05 Realtime Telemetry 0x06 Change Video Quality 0x07 Initiate Network Test 0x08 Network Information 0x09 Network Test Response 0x0A Controller Event 0x0B","title":"Control Payload Type"},{"location":"nano/#session-init","text":"Offset (hex) Offset (dec) Type Description 0x00 0 byte[] Unknown","title":"Session Init"},{"location":"nano/#session-create","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Length 0x04 4 byte[length] Unknown","title":"Session Create"},{"location":"nano/#session-create-response","text":"Offset (hex) Offset (dec) Type Description 0x00 0 byte[] Unknown","title":"Session Create Response"},{"location":"nano/#session-destroy","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Length 0x08 8 uint32 Unknown 2","title":"Session Destroy"},{"location":"nano/#video-statistics","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Unknown 2 0x08 8 uint32 Unknown 3 0x0C 12 uint32 Unknown 4 0x10 16 uint32 Unknown 5 0x14 20 uint32 Unknown 6","title":"Video Statistics"},{"location":"nano/#realtime-telemetry","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Field count 0x02 2 TelemetryField[count] Telemetry Fields","title":"Realtime Telemetry"},{"location":"nano/#telemetry-field","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Key 0x02 2 uint64 Value","title":"Telemetry Field"},{"location":"nano/#change-video-quality","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Unknown 2 0x08 8 uint32 Unknown 3 0x0C 12 uint32 Unknown 4 0x10 16 uint32 Unknown 5 0x14 20 uint32 Unknown 6","title":"Change Video Quality"},{"location":"nano/#initiate-network-test","text":"Offset (hex) Offset (dec) Type Description 0x00 0 byte[] Unknown","title":"Initiate Network Test"},{"location":"nano/#network-information","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint64 Unknown 1 0x08 8 byte Unknown 2 0x09 9 uint32 Unknown 3","title":"Network Information"},{"location":"nano/#network-test-response","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Unknown 1 0x04 4 uint32 Unknown 2 0x08 8 uint32 Unknown 3 0x0C 12 uint32 Unknown 4 0x10 16 uint32 Unknown 5 0x14 20 uint64 Unknown 6 0x1C 28 uint64 Unknown 7 0x24 36 uint32 Unknown 8","title":"Network Test Response"},{"location":"nano/#controller-event","text":"By sending a Controller Event packet to the console, the console will open the Input / Input Feedback channels and send the appropriate Channel Open packets to the client. Offset (hex) Offset (dec) Type Description 0x00 0 byte Event 0x01 1 byte Controller Number Event : Controller Event Type Controller Number : Null-indexed controller number","title":"Controller Event"},{"location":"nano/#controller-event-type","text":"Event Value Removed 0x00 Added 0x01","title":"Controller Event Type"},{"location":"simple_message/","text":"Simple Message Simple Message General Header Packet Type Power On Request Discovery Packet Discovery Request Client Type Discovery Response Primary Device Flags Certificate Connect Packet Connect Request Public Key Type Fragmenting Request Request Group explaination Connect Response Connect Result General Simple Messages are used for the most basic tasks in SmartGlass Discovering consoles on the network Waking up consoles (Power On) Connecting to consoles Header Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Packet Type 0x02 2 uint16 Unprotected Payload Length 0x04 4 uint16 *Protected Payload Length 0x06 or 0x08 6 or 8 uint16 Version NOTE: The header only contains the protected payload length-field if packet actually has such payload: SimpleMessage containing protected payload: Connect Request Connect Response Packet Type : See Packet Type Version : Usually 2, Discovery has set this to 0 Packet Type Value Description 0xCC00 Connect Request 0xCC01 Connect Response 0xDD00 Discovery Request 0xDD01 Discovery Response 0xDD02 Power On Request Message packets (type: 0xD00D ) have a different header and are not considered SimpleMessage Power On Request Packet Type : 0xDD02 Response : None This packet is sent over broadcast / multicast and directly to the console's IP address. Broadcast (255.255.255.255) Multicast (239.255.255.250) Specific IP of the console (if available) If the console is in standby-mode, it will process that packet and power on. NOTE: You may need to send the packet multiple times to make sure it is actually received by the console. Power On request packets only have an Unprotected payload Offset (hex) Offset (dec) Type Description 0x00 0 SGString Live ID Discovery Packet Discovery packet, as the name suggests, is used for finding active consoles on the network. Same as Power On Request , the packet is sent to 3 remote endpoints: Broadcast (255.255.255.255) Multicast (239.255.255.250) Specific IP of the console (if available) The console will respond by sending a Discovery Response to the sending IP. Discovery packets set Header->Version: 0 Discovery packets only have an Unprotected payload Discovery Request Packet Type : 0xDD00 Response : Discovery Response Discovers active consoles on the network Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags 0x04 4 uint16 Client Type 0x06 6 uint16 Minimum Version 0x08 8 uint16 Maximum Version Flags : Unknown, always 0 Client Type : See Client Type Minimum Version : Minimum version to discover: 0 Maximum Version : Maximum version to discover: 2 Client Type Type Value Xbox One 0x01 Xbox 360 0x02 Windows Desktop 0x03 Windows Store 0x04 Windows Phone 0x05 iPhone 0x06 iPad 0x07 Android 0x08 Discovery Response Packet Type : 0xDD01 Response : None Console info for the client Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Primary Device Flags 0x04 4 uint16 Type 0x08 8 SGString ConsoleName 0x?? ? SGString UUID 0x?? ? uint32 Last Error 0x?? ? uint16 Certificate Length 0x?? ? char[len] Certificate Primary Device Flags : See Primary Device Flags Type : See Client Type ConsoleName : Console Name UUID : Console UUID aka Hardware Id Last Error : Last error Certificate : See Certificate Primary Device Flags Flag Bits Mask Allow Console Users 0000 0000 0000 0001 0x01 Allow Authenticated Users 0000 0000 0000 0010 0x02 Allow Anonymous Users 0000 0000 0000 0100 0x04 Certificate Pending 0000 0000 0000 1000 0x08 Certificate Certificate is X509 ASN.1 / DER formatted. Fields : Version : 3 Serial Number : Console serial number Issuer : CN=XBL Smart Glass Issuing CA Validity : Validity timespan Subject : Console's LiveId ( CN=<LiveId> ) Subject Public Key Info : Console's public key TIP: You can get a human-readable output for the cert via openssl: openssl x509 -inform der -in <smartglass certificate> -text -noout Connect Packet Connect Request Packet Type : 0xCC00 Response : Connect Response The request is sent from client to console. Based on the previously received Discovery Response , a shared secret is calculated and the request is encrypted using that (See Cryptography ). Public Key Type Public Key identifier, sent with Connect Request packet. Type Value Size EC DH P256 0x00 65 EC DH P384 0x01 97 EC DH P521 0x02 133 Fragmenting Request When connecting authenticated, the Authentication data (userhash, authorization token) won't fit inside a single packet, which means the packet will need to be fragmented. Calculate payload length (plaintext unprotected + plaintext protected) of assembled Connect Request using empty Userhash (\"\") and Auth Token (\"\"). Calculate available space by available space = (1024 - payload length) Assemble first fragment by copying whole Userhash and filling up the rest of available space with Auth Token . Assemble rest of fragments by just filling them with Auth Token chunks. NOTE: Make sure to use correct Request (Group) numbering, see Request Group explaination Unprotected Payload Offset (hex) Offset (dec) Type Description 0x00 0 byte[16] SmartGlass UUID 0x10 16 uint16 Public Key Type 0x12 18 byte[??] Public Key 0x52 82 byte[16] IV SmartGlass UUID : Random UUID generated by the client Public Key Type : See Public Key Type Public Key : Public Key, size depends on Public Key Type IV : Initialization Vector of the encrypted packet Protected Payload Because strings are of variable length it's not possible to give absolute offsets here Offset (hex) Offset (dec) Type Description 0x0 0 SGString Userhash 0x? ? SGString Auth Token 0x? ? uint32 Request Number 0x? ? uint32 Request Group Start 0x? ? uint32 Request Group End Userhash : Xbox Live Userhash ( uhs ) Auth Token : Xbox Live Auth token ( XSTS ) Request Number : Current request number Request Group Start : First request number of this group Request Group End : Last request number of that group + 1 Request Group explaination Example : If you just have a single connect fragment, assume request number 0: Request Number: 0, Request Group Start: 0, Request Group End: 1 Next connect attempt, if needed, would be: Request Number: 1, Request Group Start: 1, Request Group End: 2 Example 2 : You have 3 connect fragments, starting again with request number 0: Fragment #1: Request Number: 0, Request Group Start: 0, Request Group End: 3 Fragment #2: Request Number: 1, Request Group Start: 0, Request Group End: 3 Fragment #3: Request Number: 2, Request Group Start: 0, Request Group End: 3 Connect Response Packet Type : 0xCC01 Response : None If the request was formatted and encrypted properly, the console responds with the following packet: Unprotected Payload Offset (hex) Offset (dec) Type Description 0x00 0 byte[16] IV IV : Initialization Vector of the encrypted packet Protected Payload Offset (hex) Offset (dec) Type Description 0x0 0 uint16 Connect Result 0x2 2 uint16 Pairing State 0x4 4 uint32 Participant ID Connect Result : Indicates status of the connect attempt, see Connect Result Pairing State : Pairing state of the client Participant Id : Auto-incremented index given to the client by the console. Received Messages in the active session have to match that Id in their Target Participant Id field. Connect Result Result Value Success 0x00 Pending 0x01 Error Value Unknown 0x02 Anonymous Connection Disabled 0x03 Device Limit Exceeded 0x04 SmartGlass disabled 0x05 User Auth failed 0x06 User SignIn failed 0x07 User SignIn timeout 0x08 User SignIn required 0x09","title":"Simple Message"},{"location":"simple_message/#simple-message","text":"Simple Message General Header Packet Type Power On Request Discovery Packet Discovery Request Client Type Discovery Response Primary Device Flags Certificate Connect Packet Connect Request Public Key Type Fragmenting Request Request Group explaination Connect Response Connect Result","title":"Simple Message"},{"location":"simple_message/#general","text":"Simple Messages are used for the most basic tasks in SmartGlass Discovering consoles on the network Waking up consoles (Power On) Connecting to consoles","title":"General"},{"location":"simple_message/#header","text":"Offset (hex) Offset (dec) Type Description 0x00 0 uint16 Packet Type 0x02 2 uint16 Unprotected Payload Length 0x04 4 uint16 *Protected Payload Length 0x06 or 0x08 6 or 8 uint16 Version NOTE: The header only contains the protected payload length-field if packet actually has such payload: SimpleMessage containing protected payload: Connect Request Connect Response Packet Type : See Packet Type Version : Usually 2, Discovery has set this to 0","title":"Header"},{"location":"simple_message/#packet-type","text":"Value Description 0xCC00 Connect Request 0xCC01 Connect Response 0xDD00 Discovery Request 0xDD01 Discovery Response 0xDD02 Power On Request Message packets (type: 0xD00D ) have a different header and are not considered SimpleMessage","title":"Packet Type"},{"location":"simple_message/#power-on-request","text":"Packet Type : 0xDD02 Response : None This packet is sent over broadcast / multicast and directly to the console's IP address. Broadcast (255.255.255.255) Multicast (239.255.255.250) Specific IP of the console (if available) If the console is in standby-mode, it will process that packet and power on. NOTE: You may need to send the packet multiple times to make sure it is actually received by the console. Power On request packets only have an Unprotected payload Offset (hex) Offset (dec) Type Description 0x00 0 SGString Live ID","title":"Power On Request"},{"location":"simple_message/#discovery-packet","text":"Discovery packet, as the name suggests, is used for finding active consoles on the network. Same as Power On Request , the packet is sent to 3 remote endpoints: Broadcast (255.255.255.255) Multicast (239.255.255.250) Specific IP of the console (if available) The console will respond by sending a Discovery Response to the sending IP. Discovery packets set Header->Version: 0 Discovery packets only have an Unprotected payload","title":"Discovery Packet"},{"location":"simple_message/#discovery-request","text":"Packet Type : 0xDD00 Response : Discovery Response Discovers active consoles on the network Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Flags 0x04 4 uint16 Client Type 0x06 6 uint16 Minimum Version 0x08 8 uint16 Maximum Version Flags : Unknown, always 0 Client Type : See Client Type Minimum Version : Minimum version to discover: 0 Maximum Version : Maximum version to discover: 2","title":"Discovery Request"},{"location":"simple_message/#client-type","text":"Type Value Xbox One 0x01 Xbox 360 0x02 Windows Desktop 0x03 Windows Store 0x04 Windows Phone 0x05 iPhone 0x06 iPad 0x07 Android 0x08","title":"Client Type"},{"location":"simple_message/#discovery-response","text":"Packet Type : 0xDD01 Response : None Console info for the client Offset (hex) Offset (dec) Type Description 0x00 0 uint32 Primary Device Flags 0x04 4 uint16 Type 0x08 8 SGString ConsoleName 0x?? ? SGString UUID 0x?? ? uint32 Last Error 0x?? ? uint16 Certificate Length 0x?? ? char[len] Certificate Primary Device Flags : See Primary Device Flags Type : See Client Type ConsoleName : Console Name UUID : Console UUID aka Hardware Id Last Error : Last error Certificate : See Certificate","title":"Discovery Response"},{"location":"simple_message/#primary-device-flags","text":"Flag Bits Mask Allow Console Users 0000 0000 0000 0001 0x01 Allow Authenticated Users 0000 0000 0000 0010 0x02 Allow Anonymous Users 0000 0000 0000 0100 0x04 Certificate Pending 0000 0000 0000 1000 0x08","title":"Primary Device Flags"},{"location":"simple_message/#certificate","text":"Certificate is X509 ASN.1 / DER formatted. Fields : Version : 3 Serial Number : Console serial number Issuer : CN=XBL Smart Glass Issuing CA Validity : Validity timespan Subject : Console's LiveId ( CN=<LiveId> ) Subject Public Key Info : Console's public key TIP: You can get a human-readable output for the cert via openssl: openssl x509 -inform der -in <smartglass certificate> -text -noout","title":"Certificate"},{"location":"simple_message/#connect-packet","text":"","title":"Connect Packet"},{"location":"simple_message/#connect-request","text":"Packet Type : 0xCC00 Response : Connect Response The request is sent from client to console. Based on the previously received Discovery Response , a shared secret is calculated and the request is encrypted using that (See Cryptography ).","title":"Connect Request"},{"location":"simple_message/#public-key-type","text":"Public Key identifier, sent with Connect Request packet. Type Value Size EC DH P256 0x00 65 EC DH P384 0x01 97 EC DH P521 0x02 133","title":"Public Key Type"},{"location":"simple_message/#fragmenting-request","text":"When connecting authenticated, the Authentication data (userhash, authorization token) won't fit inside a single packet, which means the packet will need to be fragmented. Calculate payload length (plaintext unprotected + plaintext protected) of assembled Connect Request using empty Userhash (\"\") and Auth Token (\"\"). Calculate available space by available space = (1024 - payload length) Assemble first fragment by copying whole Userhash and filling up the rest of available space with Auth Token . Assemble rest of fragments by just filling them with Auth Token chunks. NOTE: Make sure to use correct Request (Group) numbering, see Request Group explaination Unprotected Payload Offset (hex) Offset (dec) Type Description 0x00 0 byte[16] SmartGlass UUID 0x10 16 uint16 Public Key Type 0x12 18 byte[??] Public Key 0x52 82 byte[16] IV SmartGlass UUID : Random UUID generated by the client Public Key Type : See Public Key Type Public Key : Public Key, size depends on Public Key Type IV : Initialization Vector of the encrypted packet Protected Payload Because strings are of variable length it's not possible to give absolute offsets here Offset (hex) Offset (dec) Type Description 0x0 0 SGString Userhash 0x? ? SGString Auth Token 0x? ? uint32 Request Number 0x? ? uint32 Request Group Start 0x? ? uint32 Request Group End Userhash : Xbox Live Userhash ( uhs ) Auth Token : Xbox Live Auth token ( XSTS ) Request Number : Current request number Request Group Start : First request number of this group Request Group End : Last request number of that group + 1","title":"Fragmenting Request"},{"location":"simple_message/#request-group-explaination","text":"Example : If you just have a single connect fragment, assume request number 0: Request Number: 0, Request Group Start: 0, Request Group End: 1 Next connect attempt, if needed, would be: Request Number: 1, Request Group Start: 1, Request Group End: 2 Example 2 : You have 3 connect fragments, starting again with request number 0: Fragment #1: Request Number: 0, Request Group Start: 0, Request Group End: 3 Fragment #2: Request Number: 1, Request Group Start: 0, Request Group End: 3 Fragment #3: Request Number: 2, Request Group Start: 0, Request Group End: 3","title":"Request Group explaination"},{"location":"simple_message/#connect-response","text":"Packet Type : 0xCC01 Response : None If the request was formatted and encrypted properly, the console responds with the following packet: Unprotected Payload Offset (hex) Offset (dec) Type Description 0x00 0 byte[16] IV IV : Initialization Vector of the encrypted packet Protected Payload Offset (hex) Offset (dec) Type Description 0x0 0 uint16 Connect Result 0x2 2 uint16 Pairing State 0x4 4 uint32 Participant ID Connect Result : Indicates status of the connect attempt, see Connect Result Pairing State : Pairing state of the client Participant Id : Auto-incremented index given to the client by the console. Received Messages in the active session have to match that Id in their Target Participant Id field.","title":"Connect Response"},{"location":"simple_message/#connect-result","text":"Result Value Success 0x00 Pending 0x01 Error Value Unknown 0x02 Anonymous Connection Disabled 0x03 Device Limit Exceeded 0x04 SmartGlass disabled 0x05 User Auth failed 0x06 User SignIn failed 0x07 User SignIn timeout 0x08 User SignIn required 0x09","title":"Connect Result"}]}